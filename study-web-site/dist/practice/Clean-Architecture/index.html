<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Senior .NET study guide for Clean Architecture" />
  <meta name="theme-color" content="#0f172a" />
  <title>Clean Architecture | C# Interview Prep Cheat Sheet</title>
  <link rel="manifest" href="..\..\assets/manifest.webmanifest" />
  <script>
    (() => {
      const supported = ['dark2', 'light', 'dark'];
      const saved = sessionStorage.getItem('study-theme');
      const normalized = saved === 'midnight' ? 'dark2' : saved;
      const fallback = 'light';
      const initial = supported.includes(normalized) ? normalized : fallback;
      document.documentElement.dataset.theme = initial;
      window.__studyTheme = initial;
    })();
  </script>
  <link rel="stylesheet" href="..\..\assets/styles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <div>
      <p class="eyebrow">C# Interview Prep</p>
      <h1>Senior .NET Study Portal</h1>
      <p class="subtitle">Ultimate cheat sheets, patterns, and interview-ready scenarios in one place.</p>
    </div>
    <div class="header-actions">
      <div class="theme-switcher" aria-label="Theme selector">
        <label for="theme-select" class="theme-label">Theme</label>
        <select id="theme-select" class="theme-select">
          <option value="dark2">Dark 2</option>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
      <div class="badge">Fast recall</div>
    </div>
  </header>
  <div class="layout">
    <nav class="sidebar">
      <div class="sidebar-section">
        <h2>Navigation</h2>
        <div class="search-hint">Use Ctrl/Cmd + F for quick lookup</div>
        <div class="sidebar-scroll"><div class="nav-groups"><div class="sidebar-group" data-group="notes">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/core-concepts.html">Core Concepts</a></li><li><a class="nav-link" href="..\../notes/error-handling.html">Error Handling</a></li><li><a class="nav-link" href="..\../notes/logging.html">Logging</a></li><li><a class="nav-link" href="..\../notes/testing-strategies.html">Testing Strategies</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-automapper">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Automapper</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Automapper/AutoMapper.html">AutoMapper</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-big-o-complexity">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Big O Complexity</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Big-O-Complexity/index.html">Big O Complexity</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/O1-Constant-Time.html">O1 Constant Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/OLogN-Logarithmic-Time.html">OLogN Logarithmic Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/ON-Linear-Time.html">ON Linear Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/ON2-Quadratic-Time.html">ON2 Quadratic Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/ONLogN-Linearithmic-Time.html">ONLogN Linearithmic Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/Space-Complexity.html">Space Complexity</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-clean-architecture">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Clean Architecture</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Clean-Architecture/index.html">Clean Architecture</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-collections-and-enumerables">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Collections And Enumerables</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/index.html">Collections And Enumerables</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/ICollection.html">ICollection</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/IEnumerable.html">IEnumerable</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/IList.html">IList</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/IQueryable.html">IQueryable</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/IReadOnly.html">IReadOnly</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-design-patterns">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Design Patterns</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Design-Patterns/CQRS Pattern.html">CQRS Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Decorator Pattern.html">Decorator Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Factory Pattern.html">Factory Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Mediator Pattern.html">Mediator Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Observer Pattern.html">Observer Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Strategy Pattern.html">Strategy Pattern</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-dry">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / DRY</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/DRY/index.html">DRY</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-fluentvalidation">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / FluentValidation</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/FluentValidation/FluentValidation.html">FluentValidation</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-memory-allocation-discipline">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Memory Allocation Discipline</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Memory-Allocation-Discipline/index.html">Memory Allocation Discipline</a></li><li><a class="nav-link" href="..\../notes/Memory-Allocation-Discipline/Memory Allocation Discipline Example.html">Memory Allocation Discipline Example</a></li><li><a class="nav-link" href="..\../notes/Memory-Allocation-Discipline/Memory Allocation Discipline Example Async.html">Memory Allocation Discipline Example Async</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-solid">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / SOLID</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/SOLID/D-Dependency-Inversion-Principle-DIP.html">D Dependency Inversion Principle DIP</a></li><li><a class="nav-link" href="..\../notes/SOLID/I-Interface-Segregation-Principle-ISP.html">I Interface Segregation Principle ISP</a></li><li><a class="nav-link" href="..\../notes/SOLID/L-Liskov-Substitution-Principle-LSP.html">L Liskov Substitution Principle LSP</a></li><li><a class="nav-link" href="..\../notes/SOLID/O-Open-Closed-Principle-OCP.html">O Open Closed Principle OCP</a></li><li><a class="nav-link" href="..\../notes/SOLID/S-Single-Responsibility-Principle-SRP.html">S Single Responsibility Principle SRP</a></li><li><a class="nav-link" href="..\../notes/SOLID/index.html">SOLID</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-sub-notes">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Sub Notes</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/sub-notes/Async Await Deep Dive.html">Async Await Deep Dive</a></li><li><a class="nav-link" href="..\../notes/sub-notes/base-keyword.html">Base Keyword</a></li><li><a class="nav-link" href="..\../notes/sub-notes/CLR & Garbage Collector (GC).html">CLR & Garbage Collector (GC)</a></li><li><a class="nav-link" href="..\../notes/sub-notes/CLR & Garbage Collector (GC) Practical Example.html">CLR & Garbage Collector (GC) Practical Example</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Dependency Injection Lifetimes.html">Dependency Injection Lifetimes</a></li><li><a class="nav-link" href="..\../notes/sub-notes/FIFO Queues in .NET.html">FIFO Queues In .NET</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Forcing Garbage Collection.html">Forcing Garbage Collection</a></li><li><a class="nav-link" href="..\../notes/sub-notes/IDisposable Patterns.html">IDisposable Patterns</a></li><li><a class="nav-link" href="..\../notes/sub-notes/nameof-keyword.html">Nameof Keyword</a></li><li><a class="nav-link" href="..\../notes/sub-notes/NET Generational Garbage Collection (GC) Deep Dive.html">NET Generational Garbage Collection (GC) Deep Dive</a></li><li><a class="nav-link" href="..\../notes/sub-notes/RabbitMQ.html">RabbitMQ</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Reflection Overview.html">Reflection Overview</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Server vs Workstation GC.html">Server Vs Workstation GC</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Sorted Collections Interview Notes.html">Sorted Collections Interview Notes</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Sorting Algorithms.html">Sorting Algorithms</a></li><li><a class="nav-link" href="..\../notes/sub-notes/struct vs class when to use which.html">Struct Vs Class When To Use Which</a></li><li><a class="nav-link" href="..\../notes/sub-notes/types.html">Types</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-use-cases-massive-traffic">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Use Cases / Massive Traffic</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/01-async-patterns.html">01 Async Patterns</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/02-backpressure-rate-limiting.html">02 Backpressure Rate Limiting</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/03-caching-strategies.html">03 Caching Strategies</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/04-database-scaling.html">04 Database Scaling</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/05-message-queues.html">05 Message Queues</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/06-resilience-patterns.html">06 Resilience Patterns</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/07-observability.html">07 Observability</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/08-complete-example.html">08 Complete Example</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/index.html">Massive Traffic</a></li></ul>
    </div><div class="sidebar-group" data-group="practice">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/answers.html">Answers</a></li><li><a class="nav-link" href="..\../practice/core-concepts.html">Core Concepts</a></li><li><a class="nav-link" href="..\../practice/error-handling-exercises.html">Error Handling Exercises</a></li><li><a class="nav-link" href="..\../practice/logging-exercises.html">Logging Exercises</a></li><li><a class="nav-link" href="..\../practice/index.html">Practice</a></li><li><a class="nav-link" href="..\../practice/PRACTICE-STRUCTURE.html">PRACTICE STRUCTURE</a></li><li><a class="nav-link" href="..\../practice/questions.html">Questions</a></li><li><a class="nav-link" href="..\../practice/README.html">README</a></li><li><a class="nav-link" href="..\../practice/testing-strategies-exercises.html">Testing Strategies Exercises</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-automapper">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Automapper</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Automapper/index.html">Automapper</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-big-o-complexity">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Big O Complexity</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Big-O-Complexity/index.html">Big O Complexity</a></li><li><a class="nav-link" href="..\../practice/Big-O-Complexity/O1-Constant-Time-Exercises.html">O1 Constant Time Exercises</a></li><li><a class="nav-link" href="..\../practice/Big-O-Complexity/OLogN-Logarithmic-Time-Exercises.html">OLogN Logarithmic Time Exercises</a></li><li><a class="nav-link" href="..\../practice/Big-O-Complexity/ON-Linear-Time-Exercises.html">ON Linear Time Exercises</a></li><li><a class="nav-link" href="..\../practice/Big-O-Complexity/ON2-Quadratic-Time-Exercises.html">ON2 Quadratic Time Exercises</a></li><li><a class="nav-link" href="..\../practice/Big-O-Complexity/ONLogN-Linearithmic-Time-Exercises.html">ONLogN Linearithmic Time Exercises</a></li></ul>
    </div><div class="sidebar-group is-open" data-group="practice-clean-architecture">
      <button class="sidebar-group__header" type="button" aria-expanded="true">
        <span>Practice / Clean Architecture</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items"><li><a class="nav-link active" href="..\../practice/Clean-Architecture/index.html">Clean Architecture</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-collections-and-enumerables">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Collections And Enumerables</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Collections-And-Enumerables/index.html">Collections And Enumerables</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-design-patterns">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Design Patterns</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Design-Patterns/Decorator-Pattern-Exercises.html">Decorator Pattern Exercises</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/index.html">Design Patterns</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/Factory-Pattern-Exercises.html">Factory Pattern Exercises</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/Mediator-Pattern-Exercises.html">Mediator Pattern Exercises</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/Observer-Pattern-Exercises.html">Observer Pattern Exercises</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/Strategy-Pattern-Exercises.html">Strategy Pattern Exercises</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-dry">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / DRY</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/DRY/index.html">DRY</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-fluentvalidation">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / FluentValidation</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/FluentValidation/index.html">FluentValidation</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-memory-allocation-discipline">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Memory Allocation Discipline</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Memory-Allocation-Discipline/index.html">Memory Allocation Discipline</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-solid">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / SOLID</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/SOLID/S-Single-Responsibility-Principle-Exercises.html">S Single Responsibility Principle Exercises</a></li><li><a class="nav-link" href="..\../practice/SOLID/index.html">SOLID</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-sub-notes">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Sub Notes</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/sub-notes/api-lifecycle.html">Api Lifecycle</a></li><li><a class="nav-link" href="..\../practice/sub-notes/async-await-exercises.html">Async Await Exercises</a></li><li><a class="nav-link" href="..\../practice/sub-notes/async-resilience.html">Async Resilience</a></li><li><a class="nav-link" href="..\../practice/sub-notes/behavioral-questions.html">Behavioral Questions</a></li><li><a class="nav-link" href="..\../practice/sub-notes/code-assessment.html">Code Assessment</a></li><li><a class="nav-link" href="..\../practice/sub-notes/csharp-fundamentals.html">Csharp Fundamentals</a></li><li><a class="nav-link" href="..\../practice/sub-notes/csharp-system-design-questions.html">Csharp System Design Questions</a></li><li><a class="nav-link" href="..\../practice/sub-notes/data-layer.html">Data Layer</a></li><li><a class="nav-link" href="..\../practice/sub-notes/linq-collections.html">Linq Collections</a></li><li><a class="nav-link" href="..\../practice/sub-notes/messaging-integration.html">Messaging Integration</a></li><li><a class="nav-link" href="..\../practice/sub-notes/performance-memory.html">Performance Memory</a></li><li><a class="nav-link" href="..\../practice/sub-notes/replace int without variable.html">Replace Int Without Variable</a></li><li><a class="nav-link" href="..\../practice/sub-notes/struct vs class questions and answers.html">Struct Vs Class Questions And Answers</a></li><li><a class="nav-link" href="..\../practice/sub-notes/system-design.html">System Design</a></li><li><a class="nav-link" href="..\../practice/sub-notes/trading-domain.html">Trading Domain</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-use-cases-massive-traffic">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Use Cases / Massive Traffic</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Use-Cases/massive-traffic/index.html">Massive Traffic</a></li></ul>
    </div></div></div>
      </div>
    </nav>
    <main class="content">
      <article class="card">
        <div class="breadcrumbs">practice\Clean-Architecture\index.md</div>
        <h2>Clean Architecture</h2>
        <div class="toc-label">Rapid overview</div>
        <div class="toc"><ul class="toc-list"><li class="level-1"><a href="#clean-architecture---comprehensive-practice-exercises">Clean Architecture - Comprehensive Practice Exercises</a></li><li class="level-2"><a href="#table-of-contents">Table of Contents</a></li><li class="level-2"><a href="#layered-architecture-fundamentals">Layered Architecture Fundamentals</a></li><li class="level-3"><a href="#exercise-1-identify-the-four-layers">Exercise 1: Identify the Four Layers</a></li><li class="level-3"><a href="#exercise-2-violation-detection">Exercise 2: Violation Detection</a></li><li class="level-3"><a href="#exercise-3-project-structure-setup">Exercise 3: Project Structure Setup</a></li><li class="level-2"><a href="#dependency-flow-rules">Dependency Flow Rules</a></li><li class="level-3"><a href="#exercise-4-dependency-inversion-principle">Exercise 4: Dependency Inversion Principle</a></li><li class="level-3"><a href="#exercise-5-breaking-circular-dependencies">Exercise 5: Breaking Circular Dependencies</a></li><li class="level-2"><a href="#ports-and-adapters-pattern">Ports and Adapters Pattern</a></li><li class="level-3"><a href="#exercise-6-implement-ports-and-adapters">Exercise 6: Implement Ports and Adapters</a></li><li class="level-3"><a href="#exercise-7-database-adapter-pattern">Exercise 7: Database Adapter Pattern</a></li><li class="level-2"><a href="#domain-driven-design-basics">Domain-Driven Design Basics</a></li><li class="level-3"><a href="#exercise-8-ubiquitous-language">Exercise 8: Ubiquitous Language</a></li><li class="level-3"><a href="#exercise-9-bounded-contexts">Exercise 9: Bounded Contexts</a></li><li class="level-2"><a href="#entity-vs-value-object">Entity vs Value Object</a></li><li class="level-3"><a href="#exercise-10-identify-entities-and-value-objects">Exercise 10: Identify Entities and Value Objects</a></li><li class="level-3"><a href="#exercise-11-implement-value-object-with-validation">Exercise 11: Implement Value Object with Validation</a></li><li class="level-2"><a href="#aggregate-design">Aggregate Design</a></li><li class="level-3"><a href="#exercise-12-design-an-aggregate">Exercise 12: Design an Aggregate</a></li><li class="level-2"><a href="#repository-pattern">Repository Pattern</a></li><li class="level-3"><a href="#exercise-13-implement-repository-pattern">Exercise 13: Implement Repository Pattern</a></li><li class="level-2"><a href="#use-caseinteractor-implementation">Use Case/Interactor Implementation</a></li><li class="level-3"><a href="#exercise-14-cqrs-with-mediatr">Exercise 14: CQRS with MediatR</a></li><li class="level-2"><a href="#clean-architecture-in-aspnet-core">Clean Architecture in ASP.NET Core</a></li><li class="level-3"><a href="#exercise-15-configure-di-container">Exercise 15: Configure DI Container</a></li><li class="level-2"><a href="#testing-strategies">Testing Strategies</a></li><li class="level-3"><a href="#exercise-16-unit-test-domain-logic">Exercise 16: Unit Test Domain Logic</a></li><li class="level-2"><a href="#cross-cutting-concerns">Cross-Cutting Concerns</a></li><li class="level-3"><a href="#exercise-17-add-a-validation-pipeline-behavior">Exercise 17: Add a Validation Pipeline Behavior</a></li><li class="level-3"><a href="#exercise-18-add-logging-around-use-cases">Exercise 18: Add Logging Around Use Cases</a></li><li class="level-3"><a href="#exercise-19-cache-aside-decorator">Exercise 19: Cache-Aside Decorator</a></li><li class="level-2"><a href="#integration-boundaries">Integration Boundaries</a></li><li class="level-3"><a href="#exercise-20-anti-corruption-layer">Exercise 20: Anti-Corruption Layer</a></li><li class="level-3"><a href="#exercise-21-domain-events-vs-integration-events">Exercise 21: Domain Events vs Integration Events</a></li><li class="level-3"><a href="#exercise-22-outbox-pattern-placement">Exercise 22: Outbox Pattern Placement</a></li><li class="level-3"><a href="#exercise-23-external-api-retry-policy">Exercise 23: External API Retry Policy</a></li><li class="level-2"><a href="#operational-concerns">Operational Concerns</a></li><li class="level-3"><a href="#exercise-24-centralized-error-handling">Exercise 24: Centralized Error Handling</a></li><li class="level-3"><a href="#exercise-25-configuration-via-options">Exercise 25: Configuration via Options</a></li><li class="level-3"><a href="#exercise-26-multi-tenancy-context">Exercise 26: Multi-Tenancy Context</a></li><li class="level-3"><a href="#exercise-27-background-jobs-in-clean-architecture">Exercise 27: Background Jobs in Clean Architecture</a></li><li class="level-3"><a href="#exercise-28-use-a-clock-abstraction">Exercise 28: Use a Clock Abstraction</a></li><li class="level-2"><a href="#refactoring-migration">Refactoring & Migration</a></li><li class="level-3"><a href="#exercise-29-feature-slice-vs-layered-folders">Exercise 29: Feature-Slice vs Layered Folders</a></li><li class="level-3"><a href="#exercise-30-introduce-clean-architecture-gradually">Exercise 30: Introduce Clean Architecture Gradually</a></li><li class="level-3"><a href="#exercise-31-avoid-the-anemic-domain">Exercise 31: Avoid the Anemic Domain</a></li><li class="level-3"><a href="#exercise-32-dto-mapping-boundaries">Exercise 32: DTO Mapping Boundaries</a></li><li class="level-3"><a href="#exercise-33-versioning-use-cases">Exercise 33: Versioning Use Cases</a></li><li class="level-3"><a href="#exercise-34-modular-monolith-boundaries">Exercise 34: Modular Monolith Boundaries</a></li><li class="level-3"><a href="#exercise-35-define-a-unit-of-work">Exercise 35: Define a Unit of Work</a></li></ul></div>
        <h1 id="clean-architecture---comprehensive-practice-exercises">Clean Architecture - Comprehensive Practice Exercises</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ol><li><a href="#layered-architecture-fundamentals">Layered Architecture Fundamentals</a></li><li><a href="#dependency-flow-rules">Dependency Flow Rules</a></li><li><a href="#ports-and-adapters-pattern">Ports and Adapters Pattern</a></li><li><a href="#domain-driven-design-basics">Domain-Driven Design Basics</a></li><li><a href="#entity-vs-value-object">Entity vs Value Object</a></li><li><a href="#aggregate-design">Aggregate Design</a></li><li><a href="#repository-pattern">Repository Pattern</a></li><li><a href="#use-caseinteractor-implementation">Use Case/Interactor Implementation</a></li><li><a href="#clean-architecture-in-aspnet-core">Clean Architecture in ASP.NET Core</a></li><li><a href="#testing-strategies">Testing Strategies</a></li><li><a href="#cross-cutting-concerns">Cross-Cutting Concerns</a></li><li><a href="#integration-boundaries">Integration Boundaries</a></li><li><a href="#operational-concerns">Operational Concerns</a></li><li><a href="#refactoring--migration">Refactoring & Migration</a></li></ol>
<p>---</p>
<h2 id="layered-architecture-fundamentals">Layered Architecture Fundamentals</h2>
<h3 id="exercise-1-identify-the-four-layers">Exercise 1: Identify the Four Layers</h3>
<p><strong>Question:</strong> Explain each layer in Clean Architecture and what belongs in each layer. Give examples of classes that would live in each layer.</p>
<p><details> <summary>Answer</summary></p>
<p>The four main layers in Clean Architecture (from innermost to outermost):</p>
<p><strong>1. Domain Layer (Entities):</strong></p>
<ul><li>Core business rules and entities</li><li>No dependencies on outer layers</li><li>Examples:</li></ul>
<pre class="language-csharp"><code class="language-csharp">// Domain/Entities/Product.cs
public class Product
{
    public Guid Id { get; private set; }
    public string Name { get; private set; }
    public Money Price { get; private set; }

    public void UpdatePrice(Money newPrice)
    {
        if (newPrice.Amount &lt;= 0)
            throw new DomainException(&quot;Price must be positive&quot;);

        Price = newPrice;
    }
}

// Domain/ValueObjects/Money.cs
public class Money
{
    public decimal Amount { get; }
    public string Currency { get; }

    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }
}</code></pre>
<p><strong>2. Application Layer (Use Cases):</strong></p>
<ul><li>Application-specific business rules</li><li>Orchestrates domain objects</li><li>Depends only on Domain layer</li><li>Examples:</li></ul>
<pre class="language-csharp"><code class="language-csharp">// Application/UseCases/CreateProduct/CreateProductCommand.cs
public record CreateProductCommand(string Name, decimal Price, string Currency);

// Application/UseCases/CreateProduct/CreateProductHandler.cs
public class CreateProductHandler
{
    private readonly IProductRepository _repository;

    public async Task&lt;Result&lt;Guid&gt;&gt; Handle(CreateProductCommand command)
    {
        var product = Product.Create(
            command.Name,
            new Money(command.Price, command.Currency)
        );

        await _repository.AddAsync(product);
        return Result.Success(product.Id);
    }
}</code></pre>
<p><strong>3. Infrastructure Layer:</strong></p>
<ul><li>External concerns (database, file system, web services)</li><li>Implements interfaces defined in Application layer</li><li>Examples:</li></ul>
<pre class="language-csharp"><code class="language-csharp">// Infrastructure/Persistence/ProductRepository.cs
public class ProductRepository : IProductRepository
{
    private readonly ApplicationDbContext _context;

    public async Task&lt;Product&gt; GetByIdAsync(Guid id)
    {
        return await _context.Products.FindAsync(id);
    }
}

// Infrastructure/Persistence/ApplicationDbContext.cs
public class ApplicationDbContext : DbContext
{
    public DbSet&lt;Product&gt; Products { get; set; }
}</code></pre>
<p><strong>4. Presentation Layer (UI/API):</strong></p>
<ul><li>User interface or API controllers</li><li>Handles HTTP, serialization, authentication</li><li>Examples:</li></ul>
<pre class="language-csharp"><code class="language-csharp">// Presentation/Controllers/ProductsController.cs
[ApiController]
[Route(&quot;api/[controller]&quot;)]
public class ProductsController : ControllerBase
{
    private readonly IMediator _mediator;

    [HttpPost]
    public async Task&lt;IActionResult&gt; Create(CreateProductRequest request)
    {
        var command = new CreateProductCommand(
            request.Name,
            request.Price,
            request.Currency
        );

        var result = await _mediator.Send(command);
        return result.IsSuccess
            ? Ok(result.Value)
            : BadRequest(result.Error);
    }
}</code></pre>
<p><strong>Key Principle:</strong> Dependencies point inward. Outer layers depend on inner layers, never the reverse.</p>
<p></details></p>
<p>---</p>
<h3 id="exercise-2-violation-detection">Exercise 2: Violation Detection</h3>
<p><strong>Question:</strong> Identify all architectural violations in this code and explain how to fix them.</p>
<pre class="language-csharp"><code class="language-csharp">// Domain/Entities/Order.cs
public class Order
{
    public Guid Id { get; set; }
    public List&lt;OrderItem&gt; Items { get; set; }

    public void Save()
    {
        var context = new ApplicationDbContext();
        context.Orders.Add(this);
        context.SaveChanges();
    }

    public void SendEmail()
    {
        var smtpClient = new SmtpClient(&quot;smtp.gmail.com&quot;);
        smtpClient.Send(&quot;order@company.com&quot;, &quot;Order confirmation&quot;);
    }
}

// Application/Services/OrderService.cs
public class OrderService
{
    public void CreateOrder(CreateOrderRequest request)
    {
        var order = new Order
        {
            Id = Guid.NewGuid(),
            Items = request.Items
        };

        var controller = new OrdersController();
        controller.ProcessOrder(order);
    }
}</code></pre>
<p><details> <summary>Answer</summary></p>
<p><strong>Violations:</strong></p>
<ol><li><strong>Domain layer depends on Infrastructure</strong> (DbContext in Domain)</li><li><strong>Domain layer depends on External services</strong> (SmtpClient in Domain)</li><li><strong>Application layer depends on Presentation</strong> (Controller in Service)</li><li><strong>Anemic domain model</strong> (public setters, no business logic)</li></ol>
<p><strong>Fixed version:</strong></p>
<pre class="language-csharp"><code class="language-csharp">// Domain/Entities/Order.cs
public class Order
{
    public Guid Id { get; private set; }
    private readonly List&lt;OrderItem&gt; _items = new();
    public IReadOnlyCollection&lt;OrderItem&gt; Items =&gt; _items.AsReadOnly();

    private Order() { } // EF Core

    public static Order Create()
    {
        return new Order { Id = Guid.NewGuid() };
    }

    public void AddItem(Product product, int quantity)
    {
        if (quantity &lt;= 0)
            throw new DomainException(&quot;Quantity must be positive&quot;);

        var item = new OrderItem(product, quantity);
        _items.Add(item);
    }
}

// Application/Interfaces/IOrderRepository.cs
public interface IOrderRepository
{
    Task AddAsync(Order order);
    Task&lt;Order&gt; GetByIdAsync(Guid id);
}

// Application/Interfaces/IEmailService.cs
public interface IEmailService
{
    Task SendOrderConfirmationAsync(Order order);
}

// Application/UseCases/CreateOrder/CreateOrderHandler.cs
public class CreateOrderHandler
{
    private readonly IOrderRepository _repository;
    private readonly IEmailService _emailService;

    public CreateOrderHandler(IOrderRepository repository, IEmailService emailService)
    {
        _repository = repository;
        _emailService = emailService;
    }

    public async Task&lt;Guid&gt; Handle(CreateOrderCommand command)
    {
        var order = Order.Create();

        foreach (var item in command.Items)
        {
            order.AddItem(item.Product, item.Quantity);
        }

        await _repository.AddAsync(order);
        await _emailService.SendOrderConfirmationAsync(order);

        return order.Id;
    }
}

// Infrastructure/Persistence/OrderRepository.cs
public class OrderRepository : IOrderRepository
{
    private readonly ApplicationDbContext _context;

    public async Task AddAsync(Order order)
    {
        await _context.Orders.AddAsync(order);
        await _context.SaveChangesAsync();
    }
}

// Infrastructure/Email/EmailService.cs
public class EmailService : IEmailService
{
    private readonly SmtpClient _smtpClient;

    public async Task SendOrderConfirmationAsync(Order order)
    {
        // Email implementation
    }
}</code></pre>
<p><strong>Key fixes:</strong></p>
<ul><li>Remove all infrastructure dependencies from Domain</li><li>Define interfaces in Application layer</li><li>Implement interfaces in Infrastructure layer</li><li>Use dependency injection</li><li>Encapsulate domain logic with private setters</li></ul>
<p></details></p>
<p>---</p>
<h3 id="exercise-3-project-structure-setup">Exercise 3: Project Structure Setup</h3>
<p><strong>Question:</strong> Create a proper folder structure for a Clean Architecture e-commerce solution. Include all necessary projects and folders.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">ECommerce.sln
│
├── src/
│   ├── ECommerce.Domain/
│   │   ├── Entities/
│   │   │   ├── Product.cs
│   │   │   ├── Order.cs
│   │   │   ├── Customer.cs
│   │   │   └── OrderItem.cs
│   │   ├── ValueObjects/
│   │   │   ├── Money.cs
│   │   │   ├── Address.cs
│   │   │   └── Email.cs
│   │   ├── Enums/
│   │   │   ├── OrderStatus.cs
│   │   │   └── PaymentMethod.cs
│   │   ├── Exceptions/
│   │   │   ├── DomainException.cs
│   │   │   └── BusinessRuleViolationException.cs
│   │   └── Events/
│   │       ├── OrderCreatedEvent.cs
│   │       └── PaymentProcessedEvent.cs
│   │
│   ├── ECommerce.Application/
│   │   ├── Interfaces/
│   │   │   ├── Persistence/
│   │   │   │   ├── IOrderRepository.cs
│   │   │   │   ├── IProductRepository.cs
│   │   │   │   └── IUnitOfWork.cs
│   │   │   ├── Services/
│   │   │   │   ├── IEmailService.cs
│   │   │   │   ├── IPaymentService.cs
│   │   │   │   └── IInventoryService.cs
│   │   ├── UseCases/
│   │   │   ├── Orders/
│   │   │   │   ├── CreateOrder/
│   │   │   │   │   ├── CreateOrderCommand.cs
│   │   │   │   │   └── CreateOrderHandler.cs
│   │   │   │   ├── GetOrderById/
│   │   │   │   │   ├── GetOrderByIdQuery.cs
│   │   │   │   │   └── GetOrderByIdHandler.cs
│   │   │   ├── Products/
│   │   │   │   ├── CreateProduct/
│   │   │   │   └── UpdateProduct/
│   │   ├── DTOs/
│   │   │   ├── OrderDto.cs
│   │   │   └── ProductDto.cs
│   │   ├── Behaviors/
│   │   │   ├── ValidationBehavior.cs
│   │   │   └── LoggingBehavior.cs
│   │   └── Common/
│   │       ├── Result.cs
│   │       └── Error.cs
│   │
│   ├── ECommerce.Infrastructure/
│   │   ├── Persistence/
│   │   │   ├── ApplicationDbContext.cs
│   │   │   ├── Configurations/
│   │   │   │   ├── OrderConfiguration.cs
│   │   │   │   └── ProductConfiguration.cs
│   │   │   ├── Repositories/
│   │   │   │   ├── OrderRepository.cs
│   │   │   │   └── ProductRepository.cs
│   │   │   └── UnitOfWork.cs
│   │   ├── Services/
│   │   │   ├── EmailService.cs
│   │   │   └── PaymentService.cs
│   │   ├── Migrations/
│   │   └── DependencyInjection.cs
│   │
│   └── ECommerce.API/
│       ├── Controllers/
│       │   ├── OrdersController.cs
│       │   └── ProductsController.cs
│       ├── Middleware/
│       │   ├── ExceptionHandlingMiddleware.cs
│       │   └── RequestLoggingMiddleware.cs
│       ├── Filters/
│       │   └── ValidationFilter.cs
│       ├── Models/
│       │   ├── Requests/
│       │   │   ├── CreateOrderRequest.cs
│       │   │   └── UpdateProductRequest.cs
│       │   └── Responses/
│       │       ├── OrderResponse.cs
│       │       └── ProductResponse.cs
│       ├── Program.cs
│       └── appsettings.json
│
└── tests/
    ├── ECommerce.Domain.Tests/
    ├── ECommerce.Application.Tests/
    ├── ECommerce.Infrastructure.Tests/
    └── ECommerce.API.Tests/</code></pre>
<p><strong>Project dependencies:</strong></p>
<pre class="language-csharp"><code class="language-csharp">Domain → (no dependencies)
Application → Domain
Infrastructure → Application, Domain
API → Application, Infrastructure (for DI only), Domain</code></pre>
<p><strong>Key principles:</strong></p>
<ul><li>Domain has zero dependencies</li><li>Application only depends on Domain</li><li>Infrastructure implements Application interfaces</li><li>API is composition root (DI configuration)</li></ul>
<p></details></p>
<p>---</p>
<h2 id="dependency-flow-rules">Dependency Flow Rules</h2>
<h3 id="exercise-4-dependency-inversion-principle">Exercise 4: Dependency Inversion Principle</h3>
<p><strong>Question:</strong> Demonstrate how to apply the Dependency Inversion Principle when the Application layer needs to send emails.</p>
<p><details> <summary>Answer</summary></p>
<p><strong>Problem:</strong> Application layer needs email functionality but shouldn't depend on concrete email implementations.</p>
<p><strong>Solution:</strong></p>
<pre class="language-csharp"><code class="language-csharp">// Application/Interfaces/IEmailService.cs (Application layer defines interface)
public interface IEmailService
{
    Task SendAsync(string to, string subject, string body);
    Task SendOrderConfirmationAsync(Guid orderId, string customerEmail);
}

// Application/UseCases/Orders/CompleteOrder/CompleteOrderHandler.cs
public class CompleteOrderHandler
{
    private readonly IOrderRepository _orderRepository;
    private readonly IEmailService _emailService; // Depends on abstraction

    public CompleteOrderHandler(
        IOrderRepository orderRepository,
        IEmailService emailService)
    {
        _orderRepository = orderRepository;
        _emailService = emailService;
    }

    public async Task&lt;Result&gt; Handle(CompleteOrderCommand command)
    {
        var order = await _orderRepository.GetByIdAsync(command.OrderId);
        if (order == null)
            return Result.Failure(&quot;Order not found&quot;);

        order.Complete();
        await _orderRepository.UpdateAsync(order);

        // Use abstraction - no knowledge of SMTP, SendGrid, etc.
        await _emailService.SendOrderConfirmationAsync(
            order.Id,
            order.Customer.Email
        );

        return Result.Success();
    }
}

// Infrastructure/Email/SmtpEmailService.cs (Infrastructure implements)
public class SmtpEmailService : IEmailService
{
    private readonly SmtpClient _smtpClient;
    private readonly ILogger&lt;SmtpEmailService&gt; _logger;

    public SmtpEmailService(
        IOptions&lt;EmailSettings&gt; settings,
        ILogger&lt;SmtpEmailService&gt; logger)
    {
        _logger = logger;
        _smtpClient = new SmtpClient(settings.Value.Host)
        {
            Port = settings.Value.Port,
            Credentials = new NetworkCredential(
                settings.Value.Username,
                settings.Value.Password
            )
        };
    }

    public async Task SendAsync(string to, string subject, string body)
    {
        var message = new MailMessage(&quot;noreply@company.com&quot;, to, subject, body);
        await _smtpClient.SendMailAsync(message);
        _logger.LogInformation(&quot;Email sent to {Email}&quot;, to);
    }

    public async Task SendOrderConfirmationAsync(Guid orderId, string customerEmail)
    {
        var subject = $&quot;Order Confirmation - {orderId}&quot;;
        var body = $&quot;Your order {orderId} has been confirmed.&quot;;
        await SendAsync(customerEmail, subject, body);
    }
}

// Infrastructure/Email/SendGridEmailService.cs (Alternative implementation)
public class SendGridEmailService : IEmailService
{
    private readonly ISendGridClient _client;

    public async Task SendAsync(string to, string subject, string body)
    {
        var msg = new SendGridMessage
        {
            From = new EmailAddress(&quot;noreply@company.com&quot;),
            Subject = subject,
            PlainTextContent = body
        };
        msg.AddTo(new EmailAddress(to));

        await _client.SendEmailAsync(msg);
    }

    public async Task SendOrderConfirmationAsync(Guid orderId, string customerEmail)
    {
        // SendGrid-specific implementation
    }
}

// API/Program.cs (Composition Root - where dependency is resolved)
builder.Services.AddScoped&lt;IEmailService, SmtpEmailService&gt;();
// OR
builder.Services.AddScoped&lt;IEmailService, SendGridEmailService&gt;();</code></pre>
<p><strong>Key benefits:</strong></p>
<ol><li>Application layer doesn't know about SMTP, SendGrid, etc.</li><li>Easy to swap implementations</li><li>Easy to test (mock IEmailService)</li><li>Application layer defines what it needs</li><li>Infrastructure provides implementation</li></ol>
<p><strong>Testing:</strong></p>
<pre class="language-csharp"><code class="language-csharp">// Application.Tests/CompleteOrderHandlerTests.cs
public class CompleteOrderHandlerTests
{
    [Fact]
    public async Task Handle_ShouldSendEmail_WhenOrderCompleted()
    {
        // Arrange
        var mockEmailService = new Mock&lt;IEmailService&gt;();
        var handler = new CompleteOrderHandler(
            mockOrderRepository.Object,
            mockEmailService.Object
        );

        // Act
        await handler.Handle(new CompleteOrderCommand(orderId));

        // Assert
        mockEmailService.Verify(
            x =&gt; x.SendOrderConfirmationAsync(orderId, It.IsAny&lt;string&gt;()),
            Times.Once
        );
    }
}</code></pre>
<p></details></p>
<p>---</p>
<h3 id="exercise-5-breaking-circular-dependencies">Exercise 5: Breaking Circular Dependencies</h3>
<p><strong>Question:</strong> Fix the circular dependency in this code structure.</p>
<pre class="language-csharp"><code class="language-csharp">// Application/Services/OrderService.cs
public class OrderService
{
    private readonly ProductService _productService;

    public void CreateOrder(CreateOrderDto dto)
    {
        var product = _productService.GetProduct(dto.ProductId);
        // Create order
    }
}

// Application/Services/ProductService.cs
public class ProductService
{
    private readonly OrderService _orderService;

    public void UpdateStock(Guid productId)
    {
        var orders = _orderService.GetOrdersForProduct(productId);
        // Update stock
    }
}</code></pre>
<p><details> <summary>Answer</summary></p>
<p><strong>Problem:</strong> OrderService → ProductService → OrderService (circular dependency)</p>
<p><strong>Solution 1: Extract Common Logic to Domain</strong></p>
<pre class="language-csharp"><code class="language-csharp">// Domain/Entities/Product.cs
public class Product
{
    public Guid Id { get; private set; }
    public string Name { get; private set; }
    public int StockQuantity { get; private set; }

    public bool HasSufficientStock(int quantity)
    {
        return StockQuantity &gt;= quantity;
    }

    public void ReserveStock(int quantity)
    {
        if (!HasSufficientStock(quantity))
            throw new DomainException(&quot;Insufficient stock&quot;);

        StockQuantity -= quantity;
    }
}

// Application/UseCases/Orders/CreateOrder/CreateOrderHandler.cs
public class CreateOrderHandler
{
    private readonly IOrderRepository _orderRepository;
    private readonly IProductRepository _productRepository;

    public async Task&lt;Result&lt;Guid&gt;&gt; Handle(CreateOrderCommand command)
    {
        var product = await _productRepository.GetByIdAsync(command.ProductId);
        if (product == null)
            return Result.Failure&lt;Guid&gt;(&quot;Product not found&quot;);

        // Domain logic handles stock
        product.ReserveStock(command.Quantity);

        var order = Order.Create(command.CustomerId);
        order.AddItem(product, command.Quantity);

        await _productRepository.UpdateAsync(product);
        await _orderRepository.AddAsync(order);

        return Result.Success(order.Id);
    }
}

// Application/UseCases/Products/UpdateStock/UpdateStockHandler.cs
public class UpdateStockHandler
{
    private readonly IProductRepository _productRepository;

    public async Task&lt;Result&gt; Handle(UpdateStockCommand command)
    {
        var product = await _productRepository.GetByIdAsync(command.ProductId);
        if (product == null)
            return Result.Failure(&quot;Product not found&quot;);

        product.AddStock(command.Quantity);
        await _productRepository.UpdateAsync(product);

        return Result.Success();
    }
}</code></pre>
<p><strong>Solution 2: Use Domain Events</strong></p>
<pre class="language-csharp"><code class="language-csharp">// Domain/Events/OrderCreatedEvent.cs
public record OrderCreatedEvent(Guid OrderId, Guid ProductId, int Quantity);

// Domain/Entities/Order.cs
public class Order
{
    private readonly List&lt;IDomainEvent&gt; _domainEvents = new();
    public IReadOnlyList&lt;IDomainEvent&gt; DomainEvents =&gt; _domainEvents;

    public static Order Create(Guid customerId, Guid productId, int quantity)
    {
        var order = new Order { Id = Guid.NewGuid() };
        order._domainEvents.Add(new OrderCreatedEvent(order.Id, productId, quantity));
        return order;
    }

    public void ClearDomainEvents() =&gt; _domainEvents.Clear();
}

// Application/EventHandlers/OrderCreatedEventHandler.cs
public class OrderCreatedEventHandler : INotificationHandler&lt;OrderCreatedEvent&gt;
{
    private readonly IProductRepository _productRepository;

    public async Task Handle(OrderCreatedEvent notification, CancellationToken ct)
    {
        var product = await _productRepository.GetByIdAsync(notification.ProductId);
        product.ReserveStock(notification.Quantity);
        await _productRepository.UpdateAsync(product);
    }
}

// Infrastructure/Persistence/ApplicationDbContext.cs
public override async Task&lt;int&gt; SaveChangesAsync(CancellationToken ct = default)
{
    var domainEvents = ChangeTracker.Entries&lt;Entity&gt;()
        .SelectMany(e =&gt; e.Entity.DomainEvents)
        .ToList();

    var result = await base.SaveChangesAsync(ct);

    foreach (var domainEvent in domainEvents)
    {
        await _mediator.Publish(domainEvent, ct);
    }

    return result;
}</code></pre>
<p><strong>Solution 3: Use Mediator Pattern (if really needed)</strong></p>
<pre class="language-csharp"><code class="language-csharp">// Application/UseCases/Orders/CreateOrder/CreateOrderHandler.cs
public class CreateOrderHandler
{
    private readonly IMediator _mediator;
    private readonly IOrderRepository _orderRepository;

    public async Task&lt;Result&lt;Guid&gt;&gt; Handle(CreateOrderCommand command)
    {
        // Query for product instead of direct dependency
        var productResult = await _mediator.Send(
            new GetProductQuery(command.ProductId)
        );

        if (!productResult.IsSuccess)
            return Result.Failure&lt;Guid&gt;(productResult.Error);

        var order = Order.Create(command.CustomerId);
        await _orderRepository.AddAsync(order);

        return Result.Success(order.Id);
    }
}</code></pre>
<p><strong>Key principles:</strong></p>
<ul><li>Prefer domain logic over services</li><li>Use domain events for decoupling</li><li>Use mediator for queries between use cases</li><li>Avoid service-to-service dependencies</li></ul>
<p></details></p>
<p>---</p>
<h2 id="ports-and-adapters-pattern">Ports and Adapters Pattern</h2>
<h3 id="exercise-6-implement-ports-and-adapters">Exercise 6: Implement Ports and Adapters</h3>
<p><strong>Question:</strong> Implement a payment processing system using the Ports and Adapters pattern that supports multiple payment providers.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">// Application/Ports/IPaymentGateway.cs (Port - defined in Application)
public interface IPaymentGateway
{
    Task&lt;PaymentResult&gt; ProcessPaymentAsync(PaymentRequest request);
    Task&lt;RefundResult&gt; RefundPaymentAsync(string transactionId, decimal amount);
    Task&lt;PaymentStatus&gt; GetPaymentStatusAsync(string transactionId);
}

// Application/DTOs/Payment.cs
public record PaymentRequest(
    decimal Amount,
    string Currency,
    string CardNumber,
    string CVV,
    DateTime ExpiryDate
);

public record PaymentResult(
    bool Success,
    string TransactionId,
    string Message,
    DateTime ProcessedAt
);

public record RefundResult(bool Success, string RefundId, string Message);

public enum PaymentStatus
{
    Pending,
    Completed,
    Failed,
    Refunded
}

// Application/UseCases/ProcessPayment/ProcessPaymentHandler.cs
public class ProcessPaymentHandler
{
    private readonly IPaymentGateway _paymentGateway;
    private readonly IOrderRepository _orderRepository;
    private readonly ILogger&lt;ProcessPaymentHandler&gt; _logger;

    public ProcessPaymentHandler(
        IPaymentGateway paymentGateway,
        IOrderRepository orderRepository,
        ILogger&lt;ProcessPaymentHandler&gt; logger)
    {
        _paymentGateway = paymentGateway;
        _orderRepository = orderRepository;
        _logger = logger;
    }

    public async Task&lt;Result&gt; Handle(ProcessPaymentCommand command)
    {
        var order = await _orderRepository.GetByIdAsync(command.OrderId);
        if (order == null)
            return Result.Failure(&quot;Order not found&quot;);

        var request = new PaymentRequest(
            order.TotalAmount,
            &quot;USD&quot;,
            command.CardNumber,
            command.CVV,
            command.ExpiryDate
        );

        var result = await _paymentGateway.ProcessPaymentAsync(request);

        if (result.Success)
        {
            order.MarkAsPaid(result.TransactionId);
            await _orderRepository.UpdateAsync(order);
            _logger.LogInformation(&quot;Payment processed: {TransactionId}&quot;, result.TransactionId);
        }

        return result.Success
            ? Result.Success()
            : Result.Failure(result.Message);
    }
}

// Infrastructure/Adapters/Stripe/StripePaymentAdapter.cs (Adapter)
public class StripePaymentAdapter : IPaymentGateway
{
    private readonly StripeClient _stripeClient;
    private readonly ILogger&lt;StripePaymentAdapter&gt; _logger;

    public StripePaymentAdapter(
        IOptions&lt;StripeSettings&gt; settings,
        ILogger&lt;StripePaymentAdapter&gt; logger)
    {
        _stripeClient = new StripeClient(settings.Value.ApiKey);
        _logger = logger;
    }

    public async Task&lt;PaymentResult&gt; ProcessPaymentAsync(PaymentRequest request)
    {
        try
        {
            var options = new ChargeCreateOptions
            {
                Amount = (long)(request.Amount * 100), // Stripe uses cents
                Currency = request.Currency.ToLower(),
                Source = CreateTokenFromCard(request),
                Description = &quot;Order payment&quot;
            };

            var service = new ChargeService(_stripeClient);
            var charge = await service.CreateAsync(options);

            return new PaymentResult(
                Success: charge.Status == &quot;succeeded&quot;,
                TransactionId: charge.Id,
                Message: charge.Status,
                ProcessedAt: DateTime.UtcNow
            );
        }
        catch (StripeException ex)
        {
            _logger.LogError(ex, &quot;Stripe payment failed&quot;);
            return new PaymentResult(false, null, ex.Message, DateTime.UtcNow);
        }
    }

    public async Task&lt;RefundResult&gt; RefundPaymentAsync(string transactionId, decimal amount)
    {
        var options = new RefundCreateOptions
        {
            Charge = transactionId,
            Amount = (long)(amount * 100)
        };

        var service = new RefundService(_stripeClient);
        var refund = await service.CreateAsync(options);

        return new RefundResult(
            refund.Status == &quot;succeeded&quot;,
            refund.Id,
            refund.Status
        );
    }

    public async Task&lt;PaymentStatus&gt; GetPaymentStatusAsync(string transactionId)
    {
        var service = new ChargeService(_stripeClient);
        var charge = await service.GetAsync(transactionId);

        return charge.Status switch
        {
            &quot;pending&quot; =&gt; PaymentStatus.Pending,
            &quot;succeeded&quot; =&gt; PaymentStatus.Completed,
            &quot;failed&quot; =&gt; PaymentStatus.Failed,
            &quot;refunded&quot; =&gt; PaymentStatus.Refunded,
            _ =&gt; PaymentStatus.Failed
        };
    }
}

// Infrastructure/Adapters/PayPal/PayPalPaymentAdapter.cs (Alternative Adapter)
public class PayPalPaymentAdapter : IPaymentGateway
{
    private readonly PayPalHttpClient _payPalClient;
    private readonly ILogger&lt;PayPalPaymentAdapter&gt; _logger;

    public PayPalPaymentAdapter(
        IOptions&lt;PayPalSettings&gt; settings,
        ILogger&lt;PayPalPaymentAdapter&gt; logger)
    {
        var environment = new SandboxEnvironment(
            settings.Value.ClientId,
            settings.Value.ClientSecret
        );
        _payPalClient = new PayPalHttpClient(environment);
        _logger = logger;
    }

    public async Task&lt;PaymentResult&gt; ProcessPaymentAsync(PaymentRequest request)
    {
        var orderRequest = new OrderRequest
        {
            CheckoutPaymentIntent = &quot;CAPTURE&quot;,
            PurchaseUnits = new List&lt;PurchaseUnitRequest&gt;
            {
                new PurchaseUnitRequest
                {
                    AmountWithBreakdown = new AmountWithBreakdown
                    {
                        CurrencyCode = request.Currency,
                        Value = request.Amount.ToString(&quot;F2&quot;)
                    }
                }
            }
        };

        var createRequest = new OrdersCreateRequest();
        createRequest.Prefer(&quot;return=representation&quot;);
        createRequest.RequestBody(orderRequest);

        try
        {
            var response = await _payPalClient.Execute(createRequest);
            var order = response.Result&lt;Order&gt;();

            return new PaymentResult(
                Success: order.Status == &quot;COMPLETED&quot;,
                TransactionId: order.Id,
                Message: order.Status,
                ProcessedAt: DateTime.UtcNow
            );
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;PayPal payment failed&quot;);
            return new PaymentResult(false, null, ex.Message, DateTime.UtcNow);
        }
    }

    public async Task&lt;RefundResult&gt; RefundPaymentAsync(string transactionId, decimal amount)
    {
        // PayPal refund implementation
        throw new NotImplementedException();
    }

    public async Task&lt;PaymentStatus&gt; GetPaymentStatusAsync(string transactionId)
    {
        // PayPal status check implementation
        throw new NotImplementedException();
    }
}

// Infrastructure/Adapters/MockPaymentAdapter.cs (For Testing)
public class MockPaymentAdapter : IPaymentGateway
{
    public Task&lt;PaymentResult&gt; ProcessPaymentAsync(PaymentRequest request)
    {
        // Always succeeds for testing
        return Task.FromResult(new PaymentResult(
            Success: true,
            TransactionId: Guid.NewGuid().ToString(),
            Message: &quot;Mock payment processed&quot;,
            ProcessedAt: DateTime.UtcNow
        ));
    }

    public Task&lt;RefundResult&gt; RefundPaymentAsync(string transactionId, decimal amount)
    {
        return Task.FromResult(new RefundResult(true, Guid.NewGuid().ToString(), &quot;Refunded&quot;));
    }

    public Task&lt;PaymentStatus&gt; GetPaymentStatusAsync(string transactionId)
    {
        return Task.FromResult(PaymentStatus.Completed);
    }
}

// API/Program.cs (Configuration)
var builder = WebApplication.CreateBuilder(args);

// Choose adapter based on configuration
var paymentProvider = builder.Configuration[&quot;PaymentProvider&quot;];

switch (paymentProvider)
{
    case &quot;Stripe&quot;:
        builder.Services.AddScoped&lt;IPaymentGateway, StripePaymentAdapter&gt;();
        builder.Services.Configure&lt;StripeSettings&gt;(
            builder.Configuration.GetSection(&quot;Stripe&quot;)
        );
        break;

    case &quot;PayPal&quot;:
        builder.Services.AddScoped&lt;IPaymentGateway, PayPalPaymentAdapter&gt;();
        builder.Services.Configure&lt;PayPalSettings&gt;(
            builder.Configuration.GetSection(&quot;PayPal&quot;)
        );
        break;

    case &quot;Mock&quot;:
        builder.Services.AddScoped&lt;IPaymentGateway, MockPaymentAdapter&gt;();
        break;

    default:
        throw new InvalidOperationException(&quot;Invalid payment provider&quot;);
}</code></pre>
<p><strong>Key benefits:</strong></p>
<ol><li>Application layer defines interface (port)</li><li>Infrastructure provides implementations (adapters)</li><li>Easy to swap payment providers</li><li>Easy to test with mock adapter</li><li>No vendor lock-in</li></ol>
<p></details></p>
<p>---</p>
<h3 id="exercise-7-database-adapter-pattern">Exercise 7: Database Adapter Pattern</h3>
<p><strong>Question:</strong> Create adapters for both SQL and MongoDB databases using the same port interface.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">// Application/Ports/IProductRepository.cs (Port)
public interface IProductRepository
{
    Task&lt;Product&gt; GetByIdAsync(Guid id);
    Task&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync();
    Task&lt;IEnumerable&lt;Product&gt;&gt; SearchAsync(string searchTerm);
    Task AddAsync(Product product);
    Task UpdateAsync(Product product);
    Task DeleteAsync(Guid id);
}

// Domain/Entities/Product.cs
public class Product
{
    public Guid Id { get; private set; }
    public string Name { get; private set; }
    public string Description { get; private set; }
    public decimal Price { get; private set; }
    public int StockQuantity { get; private set; }

    private Product() { }

    public static Product Create(string name, string description, decimal price, int stock)
    {
        return new Product
        {
            Id = Guid.NewGuid(),
            Name = name,
            Description = description,
            Price = price,
            StockQuantity = stock
        };
    }
}

// Infrastructure/Adapters/SqlServer/SqlProductRepository.cs (SQL Adapter)
public class SqlProductRepository : IProductRepository
{
    private readonly ApplicationDbContext _context;

    public SqlProductRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task&lt;Product&gt; GetByIdAsync(Guid id)
    {
        return await _context.Products
            .FirstOrDefaultAsync(p =&gt; p.Id == id);
    }

    public async Task&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync()
    {
        return await _context.Products.ToListAsync();
    }

    public async Task&lt;IEnumerable&lt;Product&gt;&gt; SearchAsync(string searchTerm)
    {
        return await _context.Products
            .Where(p =&gt; EF.Functions.Like(p.Name, $&quot;%{searchTerm}%&quot;) ||
                       EF.Functions.Like(p.Description, $&quot;%{searchTerm}%&quot;))
            .ToListAsync();
    }

    public async Task AddAsync(Product product)
    {
        await _context.Products.AddAsync(product);
        await _context.SaveChangesAsync();
    }

    public async Task UpdateAsync(Product product)
    {
        _context.Products.Update(product);
        await _context.SaveChangesAsync();
    }

    public async Task DeleteAsync(Guid id)
    {
        var product = await GetByIdAsync(id);
        if (product != null)
        {
            _context.Products.Remove(product);
            await _context.SaveChangesAsync();
        }
    }
}

// Infrastructure/Adapters/MongoDB/MongoProductRepository.cs (MongoDB Adapter)
public class MongoProductRepository : IProductRepository
{
    private readonly IMongoCollection&lt;ProductDocument&gt; _collection;

    public MongoProductRepository(IMongoDatabase database)
    {
        _collection = database.GetCollection&lt;ProductDocument&gt;(&quot;products&quot;);
    }

    public async Task&lt;Product&gt; GetByIdAsync(Guid id)
    {
        var filter = Builders&lt;ProductDocument&gt;.Filter.Eq(p =&gt; p.Id, id);
        var document = await _collection.Find(filter).FirstOrDefaultAsync();
        return document?.ToDomain();
    }

    public async Task&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync()
    {
        var documents = await _collection.Find(_ =&gt; true).ToListAsync();
        return documents.Select(d =&gt; d.ToDomain());
    }

    public async Task&lt;IEnumerable&lt;Product&gt;&gt; SearchAsync(string searchTerm)
    {
        var filter = Builders&lt;ProductDocument&gt;.Filter.Or(
            Builders&lt;ProductDocument&gt;.Filter.Regex(p =&gt; p.Name, new BsonRegularExpression(searchTerm, &quot;i&quot;)),
            Builders&lt;ProductDocument&gt;.Filter.Regex(p =&gt; p.Description, new BsonRegularExpression(searchTerm, &quot;i&quot;))
        );

        var documents = await _collection.Find(filter).ToListAsync();
        return documents.Select(d =&gt; d.ToDomain());
    }

    public async Task AddAsync(Product product)
    {
        var document = ProductDocument.FromDomain(product);
        await _collection.InsertOneAsync(document);
    }

    public async Task UpdateAsync(Product product)
    {
        var document = ProductDocument.FromDomain(product);
        var filter = Builders&lt;ProductDocument&gt;.Filter.Eq(p =&gt; p.Id, product.Id);
        await _collection.ReplaceOneAsync(filter, document);
    }

    public async Task DeleteAsync(Guid id)
    {
        var filter = Builders&lt;ProductDocument&gt;.Filter.Eq(p =&gt; p.Id, id);
        await _collection.DeleteOneAsync(filter);
    }
}

// Infrastructure/Adapters/MongoDB/ProductDocument.cs (MongoDB Document Model)
public class ProductDocument
{
    [BsonId]
    public Guid Id { get; set; }

    [BsonElement(&quot;name&quot;)]
    public string Name { get; set; }

    [BsonElement(&quot;description&quot;)]
    public string Description { get; set; }

    [BsonElement(&quot;price&quot;)]
    public decimal Price { get; set; }

    [BsonElement(&quot;stock_quantity&quot;)]
    public int StockQuantity { get; set; }

    public Product ToDomain()
    {
        // Use reflection or create method to construct Product
        return Product.Create(Name, Description, Price, StockQuantity);
    }

    public static ProductDocument FromDomain(Product product)
    {
        return new ProductDocument
        {
            Id = product.Id,
            Name = product.Name,
            Description = product.Description,
            Price = product.Price,
            StockQuantity = product.StockQuantity
        };
    }
}

// Infrastructure/Adapters/InMemory/InMemoryProductRepository.cs (Testing Adapter)
public class InMemoryProductRepository : IProductRepository
{
    private readonly Dictionary&lt;Guid, Product&gt; _products = new();

    public Task&lt;Product&gt; GetByIdAsync(Guid id)
    {
        _products.TryGetValue(id, out var product);
        return Task.FromResult(product);
    }

    public Task&lt;IEnumerable&lt;Product&gt;&gt; GetAllAsync()
    {
        return Task.FromResult(_products.Values.AsEnumerable());
    }

    public Task&lt;IEnumerable&lt;Product&gt;&gt; SearchAsync(string searchTerm)
    {
        var results = _products.Values
            .Where(p =&gt; p.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) ||
                       p.Description.Contains(searchTerm, StringComparison.OrdinalIgnoreCase));
        return Task.FromResult(results);
    }

    public Task AddAsync(Product product)
    {
        _products[product.Id] = product;
        return Task.CompletedTask;
    }

    public Task UpdateAsync(Product product)
    {
        _products[product.Id] = product;
        return Task.CompletedTask;
    }

    public Task DeleteAsync(Guid id)
    {
        _products.Remove(id);
        return Task.CompletedTask;
    }
}

// API/Program.cs (Configuration)
var databaseProvider = builder.Configuration[&quot;DatabaseProvider&quot;];

switch (databaseProvider)
{
    case &quot;SqlServer&quot;:
        builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
            options.UseSqlServer(builder.Configuration.GetConnectionString(&quot;SqlServer&quot;))
        );
        builder.Services.AddScoped&lt;IProductRepository, SqlProductRepository&gt;();
        break;

    case &quot;MongoDB&quot;:
        builder.Services.AddSingleton&lt;IMongoClient&gt;(sp =&gt;
            new MongoClient(builder.Configuration.GetConnectionString(&quot;MongoDB&quot;))
        );
        builder.Services.AddScoped&lt;IMongoDatabase&gt;(sp =&gt;
        {
            var client = sp.GetRequiredService&lt;IMongoClient&gt;();
            return client.GetDatabase(&quot;ECommerceDb&quot;);
        });
        builder.Services.AddScoped&lt;IProductRepository, MongoProductRepository&gt;();
        break;

    case &quot;InMemory&quot;:
        builder.Services.AddSingleton&lt;IProductRepository, InMemoryProductRepository&gt;();
        break;
}</code></pre>
<p><strong>Key benefits:</strong></p>
<ul><li>Same interface works with SQL, MongoDB, or In-Memory</li><li>Application layer doesn't know about database implementation</li><li>Easy to switch databases</li><li>Easy to test with in-memory implementation</li></ul>
<p></details></p>
<p>---</p>
<h2 id="domain-driven-design-basics">Domain-Driven Design Basics</h2>
<h3 id="exercise-8-ubiquitous-language">Exercise 8: Ubiquitous Language</h3>
<p><strong>Question:</strong> Refactor this code to use ubiquitous language from the e-commerce domain instead of technical jargon.</p>
<pre class="language-csharp"><code class="language-csharp">public class DataItem
{
    public int Id { get; set; }
    public string Field1 { get; set; }
    public decimal Field2 { get; set; }
    public int Field3 { get; set; }
    public DateTime Field4 { get; set; }
    public bool Field5 { get; set; }
}

public class DataProcessor
{
    public void ProcessData(DataItem item)
    {
        if (item.Field3 &gt; 0 &amp;&amp; !item.Field5)
        {
            item.Field5 = true;
            item.Field4 = DateTime.Now;
        }
    }
}</code></pre>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">// Domain/Entities/Order.cs
public class Order
{
    public Guid Id { get; private set; }
    public string OrderNumber { get; private set; }
    public Money TotalAmount { get; private set; }
    public int ItemCount { get; private set; }
    public DateTime PlacedAt { get; private set; }
    public OrderStatus Status { get; private set; }

    private readonly List&lt;OrderItem&gt; _items = new();
    public IReadOnlyCollection&lt;OrderItem&gt; Items =&gt; _items.AsReadOnly();

    private Order() { }

    public static Order Create(string orderNumber, Guid customerId)
    {
        return new Order
        {
            Id = Guid.NewGuid(),
            OrderNumber = orderNumber,
            PlacedAt = DateTime.UtcNow,
            Status = OrderStatus.Pending
        };
    }

    public void AddItem(Product product, int quantity)
    {
        if (Status != OrderStatus.Pending)
            throw new DomainException(&quot;Cannot add items to a confirmed order&quot;);

        var item = OrderItem.Create(product, quantity);
        _items.Add(item);
        ItemCount += quantity;
        RecalculateTotal();
    }

    public void ConfirmOrder()
    {
        if (ItemCount == 0)
            throw new DomainException(&quot;Cannot confirm an empty order&quot;);

        if (Status != OrderStatus.Pending)
            throw new DomainException(&quot;Order has already been confirmed&quot;);

        Status = OrderStatus.Confirmed;
        PlacedAt = DateTime.UtcNow;
    }

    public void CancelOrder()
    {
        if (Status == OrderStatus.Shipped)
            throw new DomainException(&quot;Cannot cancel a shipped order&quot;);

        Status = OrderStatus.Cancelled;
    }

    public void ShipOrder()
    {
        if (Status != OrderStatus.Confirmed)
            throw new DomainException(&quot;Can only ship confirmed orders&quot;);

        Status = OrderStatus.Shipped;
    }

    private void RecalculateTotal()
    {
        var total = _items.Sum(item =&gt; item.LineTotal.Amount);
        TotalAmount = new Money(total, &quot;USD&quot;);
    }
}

// Domain/Enums/OrderStatus.cs
public enum OrderStatus
{
    Pending,
    Confirmed,
    Shipped,
    Delivered,
    Cancelled
}

// Domain/Entities/OrderItem.cs
public class OrderItem
{
    public Guid Id { get; private set; }
    public Product Product { get; private set; }
    public int Quantity { get; private set; }
    public Money UnitPrice { get; private set; }
    public Money LineTotal { get; private set; }

    private OrderItem() { }

    public static OrderItem Create(Product product, int quantity)
    {
        if (quantity &lt;= 0)
            throw new DomainException(&quot;Quantity must be positive&quot;);

        var unitPrice = product.Price;
        var lineTotal = new Money(unitPrice.Amount * quantity, unitPrice.Currency);

        return new OrderItem
        {
            Id = Guid.NewGuid(),
            Product = product,
            Quantity = quantity,
            UnitPrice = unitPrice,
            LineTotal = lineTotal
        };
    }

    public void UpdateQuantity(int newQuantity)
    {
        if (newQuantity &lt;= 0)
            throw new DomainException(&quot;Quantity must be positive&quot;);

        Quantity = newQuantity;
        LineTotal = new Money(UnitPrice.Amount * newQuantity, UnitPrice.Currency);
    }
}

// Application/UseCases/Orders/ConfirmOrder/ConfirmOrderHandler.cs
public class ConfirmOrderHandler
{
    private readonly IOrderRepository _orderRepository;
    private readonly IInventoryService _inventoryService;
    private readonly ILogger&lt;ConfirmOrderHandler&gt; _logger;

    public async Task&lt;Result&gt; Handle(ConfirmOrderCommand command)
    {
        var order = await _orderRepository.GetByIdAsync(command.OrderId);
        if (order == null)
            return Result.Failure(&quot;Order not found&quot;);

        // Check inventory for all items
        foreach (var item in order.Items)
        {
            var hasStock = await _inventoryService.CheckAvailabilityAsync(
                item.Product.Id,
                item.Quantity
            );

            if (!hasStock)
                return Result.Failure($&quot;Insufficient stock for {item.Product.Name}&quot;);
        }

        // Confirm order (domain logic)
        order.ConfirmOrder();

        // Reserve inventory
        foreach (var item in order.Items)
        {
            await _inventoryService.ReserveStockAsync(
                item.Product.Id,
                item.Quantity
            );
        }

        await _orderRepository.UpdateAsync(order);

        _logger.LogInformation(
            &quot;Order {OrderNumber} confirmed with {ItemCount} items&quot;,
            order.OrderNumber,
            order.ItemCount
        );

        return Result.Success();
    }
}</code></pre>
<p><strong>Before vs After:</strong></p>
<table><thead><tr><th>Technical Term</th><th>Domain Term</th></tr></thead><tbody><tr><td>DataItem</td><td>Order</td></tr><tr><td>Field1</td><td>OrderNumber</td></tr><tr><td>Field2</td><td>TotalAmount</td></tr><tr><td>Field3</td><td>ItemCount</td></tr><tr><td>Field4</td><td>PlacedAt</td></tr><tr><td>Field5</td><td>IsConfirmed → Status</td></tr><tr><td>ProcessData</td><td>ConfirmOrder</td></tr></tbody></table>
<p><strong>Benefits:</strong></p>
<ul><li>Code reads like business requirements</li><li>Developers and domain experts speak same language</li><li>Easier to understand and maintain</li><li>Reduced translation errors</li></ul>
<p></details></p>
<p>---</p>
<h3 id="exercise-9-bounded-contexts">Exercise 9: Bounded Contexts</h3>
<p><strong>Question:</strong> Identify bounded contexts in an e-commerce system and show how the same concept (like "Product") might differ across contexts.</p>
<p><details> <summary>Answer</summary></p>
<p><strong>Identified Bounded Contexts:</strong></p>
<ol><li><strong>Catalog Context</strong> - Product browsing and searching</li><li><strong>Inventory Context</strong> - Stock management</li><li><strong>Sales Context</strong> - Order processing</li><li><strong>Shipping Context</strong> - Fulfillment and delivery</li></ol>
<pre class="language-csharp"><code class="language-csharp">// ===== CATALOG CONTEXT =====
// Catalog/Domain/Entities/Product.cs
namespace Catalog.Domain.Entities
{
    public class Product
    {
        public Guid Id { get; private set; }
        public string Name { get; private set; }
        public string Description { get; private set; }
        public Money Price { get; private set; }
        public string Category { get; private set; }
        public List&lt;string&gt; ImageUrls { get; private set; }
        public List&lt;ProductAttribute&gt; Attributes { get; private set; } // Color, Size, etc.
        public decimal AverageRating { get; private set; }
        public int ReviewCount { get; private set; }
        public bool IsPublished { get; private set; }

        public void Publish()
        {
            if (!IsValid())
                throw new DomainException(&quot;Cannot publish invalid product&quot;);
            IsPublished = true;
        }

        public void UpdateRating(decimal newRating)
        {
            // Recalculate average
        }

        private bool IsValid()
        {
            return !string.IsNullOrEmpty(Name) &amp;&amp;
                   Price.Amount &gt; 0 &amp;&amp;
                   ImageUrls.Any();
        }
    }
}

// Catalog/Application/Queries/SearchProducts/SearchProductsQuery.cs
namespace Catalog.Application.Queries
{
    public record SearchProductsQuery(
        string SearchTerm,
        string Category,
        decimal? MinPrice,
        decimal? MaxPrice,
        int PageNumber,
        int PageSize
    );
}

// ===== INVENTORY CONTEXT =====
// Inventory/Domain/Entities/InventoryItem.cs
namespace Inventory.Domain.Entities
{
    public class InventoryItem
    {
        public Guid ProductId { get; private set; } // References Catalog Product
        public string SKU { get; private set; }
        public int QuantityOnHand { get; private set; }
        public int QuantityReserved { get; private set; }
        public int ReorderLevel { get; private set; }
        public int ReorderQuantity { get; private set; }
        public Location WarehouseLocation { get; private set; }

        public int AvailableQuantity =&gt; QuantityOnHand - QuantityReserved;

        public bool NeedsReorder =&gt; AvailableQuantity &lt;= ReorderLevel;

        public void ReserveStock(int quantity)
        {
            if (AvailableQuantity &lt; quantity)
                throw new InsufficientStockException(ProductId, quantity, AvailableQuantity);

            QuantityReserved += quantity;
        }

        public void ReceiveStock(int quantity)
        {
            if (quantity &lt;= 0)
                throw new DomainException(&quot;Quantity must be positive&quot;);

            QuantityOnHand += quantity;
        }

        public void AdjustStock(int newQuantity, string reason)
        {
            // Stock adjustment logic with audit
            QuantityOnHand = newQuantity;
        }
    }

    public record Location(string Warehouse, string Aisle, string Shelf, string Bin);
}

// ===== SALES CONTEXT =====
// Sales/Domain/Entities/OrderLine.cs
namespace Sales.Domain.Entities
{
    public class OrderLine
    {
        public Guid ProductId { get; private set; } // References Catalog Product
        public string ProductName { get; private set; } // Denormalized
        public string SKU { get; private set; }
        public int Quantity { get; private set; }
        public Money UnitPrice { get; private set; } // Price at time of order
        public Money LineTotal { get; private set; }
        public decimal DiscountPercentage { get; private set; }
        public Money DiscountAmount { get; private set; }

        public void ApplyDiscount(decimal percentage)
        {
            if (percentage &lt; 0 || percentage &gt; 100)
                throw new DomainException(&quot;Invalid discount percentage&quot;);

            DiscountPercentage = percentage;
            DiscountAmount = new Money(
                LineTotal.Amount * (percentage / 100),
                LineTotal.Currency
            );
        }

        // In Sales context, product is immutable snapshot at time of order
    }

    public class Order
    {
        public Guid Id { get; private set; }
        public string OrderNumber { get; private set; }
        public Guid CustomerId { get; private set; }
        private readonly List&lt;OrderLine&gt; _lines = new();
        public IReadOnlyCollection&lt;OrderLine&gt; Lines =&gt; _lines.AsReadOnly();

        public Money Subtotal { get; private set; }
        public Money TaxAmount { get; private set; }
        public Money Total { get; private set; }
        public OrderStatus Status { get; private set; }

        public void CalculateTotals()
        {
            var subtotal = _lines.Sum(l =&gt; l.LineTotal.Amount - l.DiscountAmount.Amount);
            Subtotal = new Money(subtotal, &quot;USD&quot;);

            TaxAmount = new Money(subtotal * 0.08m, &quot;USD&quot;); // 8% tax
            Total = new Money(Subtotal.Amount + TaxAmount.Amount, &quot;USD&quot;);
        }
    }
}

// ===== SHIPPING CONTEXT =====
// Shipping/Domain/Entities/ShipmentItem.cs
namespace Shipping.Domain.Entities
{
    public class ShipmentItem
    {
        public Guid ProductId { get; private set; }
        public string SKU { get; private set; }
        public string ProductName { get; private set; }
        public int Quantity { get; private set; }
        public Weight Weight { get; private set; }
        public Dimensions Dimensions { get; private set; }
        public bool IsFragile { get; private set; }
        public bool RequiresColdStorage { get; private set; }

        // In Shipping context, we care about physical properties
        public decimal CalculateVolumetricWeight()
        {
            var volumetricWeight = (Dimensions.Length * Dimensions.Width * Dimensions.Height) / 5000;
            return Math.Max(Weight.Kilograms, volumetricWeight);
        }
    }

    public class Shipment
    {
        public Guid Id { get; private set; }
        public Guid OrderId { get; private set; } // References Sales Order
        private readonly List&lt;ShipmentItem&gt; _items = new();
        public IReadOnlyCollection&lt;ShipmentItem&gt; Items =&gt; _items.AsReadOnly();

        public Address ShippingAddress { get; private set; }
        public ShippingMethod Method { get; private set; }
        public string TrackingNumber { get; private set; }
        public DateTime? ShippedAt { get; private set; }
        public DateTime? EstimatedDelivery { get; private set; }

        public void AssignTrackingNumber(string trackingNumber)
        {
            if (string.IsNullOrWhiteSpace(trackingNumber))
                throw new DomainException(&quot;Tracking number is required&quot;);

            TrackingNumber = trackingNumber;
        }

        public void Ship()
        {
            if (string.IsNullOrEmpty(TrackingNumber))
                throw new DomainException(&quot;Cannot ship without tracking number&quot;);

            ShippedAt = DateTime.UtcNow;
            EstimatedDelivery = CalculateEstimatedDelivery();
        }

        private DateTime CalculateEstimatedDelivery()
        {
            return Method switch
            {
                ShippingMethod.Standard =&gt; DateTime.UtcNow.AddDays(5),
                ShippingMethod.Express =&gt; DateTime.UtcNow.AddDays(2),
                ShippingMethod.Overnight =&gt; DateTime.UtcNow.AddDays(1),
                _ =&gt; throw new NotImplementedException()
            };
        }
    }

    public record Weight(decimal Kilograms);
    public record Dimensions(decimal Length, decimal Width, decimal Height);
    public enum ShippingMethod { Standard, Express, Overnight }
}

// ===== CONTEXT MAPPING =====
// Shared/Integration/Events/ProductCreatedEvent.cs
namespace Shared.Integration.Events
{
    // Integration event to sync Product across contexts
    public record ProductCreatedEvent(
        Guid ProductId,
        string Name,
        string SKU,
        decimal PriceAmount,
        string Currency,
        decimal WeightKg,
        decimal Length,
        decimal Width,
        decimal Height
    );
}

// Catalog/Application/EventHandlers/PublishProductEventHandler.cs
namespace Catalog.Application.EventHandlers
{
    public class PublishProductEventHandler
    {
        private readonly IEventBus _eventBus;

        public async Task Handle(ProductPublishedDomainEvent domainEvent)
        {
            // Translate domain event to integration event
            var integrationEvent = new ProductCreatedEvent(
                domainEvent.ProductId,
                domainEvent.Name,
                domainEvent.SKU,
                domainEvent.Price.Amount,
                domainEvent.Price.Currency,
                // ... other properties
            );

            await _eventBus.PublishAsync(integrationEvent);
        }
    }
}

// Inventory/Application/EventHandlers/ProductCreatedEventHandler.cs
namespace Inventory.Application.EventHandlers
{
    public class ProductCreatedEventHandler
    {
        private readonly IInventoryRepository _repository;

        public async Task Handle(ProductCreatedEvent @event)
        {
            // Create inventory item in Inventory context
            var inventoryItem = InventoryItem.Create(
                @event.ProductId,
                @event.SKU,
                initialQuantity: 0,
                reorderLevel: 10
            );

            await _repository.AddAsync(inventoryItem);
        }
    }
}</code></pre>
<p><strong>Key Points:</strong></p>
<table><thead><tr><th>Context</th><th>Product Representation</th><th>Primary Concerns</th></tr></thead><tbody><tr><td>Catalog</td><td>Rich product info, images, reviews</td><td>Browsing, searching, merchandising</td></tr><tr><td>Inventory</td><td>SKU, quantities, location</td><td>Stock levels, warehouse management</td></tr><tr><td>Sales</td><td>Price snapshot, line items</td><td>Orders, pricing, discounts</td></tr><tr><td>Shipping</td><td>Weight, dimensions, fragility</td><td>Logistics, delivery, tracking</td></tr></tbody></table>
<p><strong>Context Integration:</strong></p>
<ul><li>Each context has its own model of "Product"</li><li>Integration events synchronize data across contexts</li><li>Anti-Corruption Layer prevents external models from polluting domain</li><li>Shared Kernel only for truly shared concepts (like Money)</li></ul>
<p></details></p>
<p>---</p>
<h2 id="entity-vs-value-object">Entity vs Value Object</h2>
<h3 id="exercise-10-identify-entities-and-value-objects">Exercise 10: Identify Entities and Value Objects</h3>
<p><strong>Question:</strong> Classify each of these as Entity or Value Object and explain why:</p>
<ol><li>Customer</li><li>Address</li><li>Money</li><li>Order</li><li>Email</li><li>ProductReview</li><li>DateRange</li></ol>
<p><details> <summary>Answer</summary></p>
<p><strong>Classification:</strong></p>
<p><strong>1. Customer - ENTITY</strong></p>
<pre class="language-csharp"><code class="language-csharp">public class Customer
{
    public Guid Id { get; private set; } // Identity
    public string FirstName { get; private set; }
    public string LastName { get; private set; }
    public Email Email { get; private set; }
    public DateTime RegisteredAt { get; private set; }

    // Identity is important - same customer even if email changes
    public void UpdateEmail(Email newEmail)
    {
        Email = newEmail;
        // Still the same customer!
    }
}</code></pre>
<p><strong>Why:</strong> Has identity, mutable, lifecycle matters, two customers with identical data are still different customers.</p>
<p><strong>2. Address - VALUE OBJECT</strong></p>
<pre class="language-csharp"><code class="language-csharp">public record Address(
    string Street,
    string City,
    string State,
    string ZipCode,
    string Country)
{
    public static Address Create(string street, string city, string state, string zip, string country)
    {
        // Validation
        if (string.IsNullOrWhiteSpace(street))
            throw new ArgumentException(&quot;Street is required&quot;);

        return new Address(street, city, state, zip, country);
    }
}

// Usage
var address1 = new Address(&quot;123 Main St&quot;, &quot;NYC&quot;, &quot;NY&quot;, &quot;10001&quot;, &quot;USA&quot;);
var address2 = new Address(&quot;123 Main St&quot;, &quot;NYC&quot;, &quot;NY&quot;, &quot;10001&quot;, &quot;USA&quot;);
// address1 == address2 (value equality)</code></pre>
<p><strong>Why:</strong> No identity, immutable, equality based on values, interchangeable if values match.</p>
<p><strong>3. Money - VALUE OBJECT</strong></p>
<pre class="language-csharp"><code class="language-csharp">public record Money(decimal Amount, string Currency)
{
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException(&quot;Cannot add different currencies&quot;);

        return new Money(Amount + other.Amount, Currency);
    }

    public Money Multiply(decimal factor)
    {
        return new Money(Amount * factor, Currency);
    }
}

// Usage
var price1 = new Money(100, &quot;USD&quot;);
var price2 = new Money(100, &quot;USD&quot;);
// price1 == price2 (value equality)</code></pre>
<p><strong>Why:</strong> No identity, immutable, defined by its value, 100 USD is always 100 USD.</p>
<p><strong>4. Order - ENTITY</strong></p>
<pre class="language-csharp"><code class="language-csharp">public class Order
{
    public Guid Id { get; private set; } // Identity
    public string OrderNumber { get; private set; }
    public OrderStatus Status { get; private set; }
    public DateTime PlacedAt { get; private set; }

    // Lifecycle and state changes matter
    public void Ship()
    {
        if (Status != OrderStatus.Confirmed)
            throw new InvalidOperationException(&quot;Can only ship confirmed orders&quot;);
        Status = OrderStatus.Shipped;
        // Still the same order, just different status
    }
}</code></pre>
<p><strong>Why:</strong> Has identity, mutable, lifecycle matters, tracks state changes over time.</p>
<p><strong>5. Email - VALUE OBJECT</strong></p>
<pre class="language-csharp"><code class="language-csharp">public record Email
{
    public string Value { get; }

    private Email(string value)
    {
        Value = value;
    }

    public static Result&lt;Email&gt; Create(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
            return Result.Failure&lt;Email&gt;(&quot;Email is required&quot;);

        if (!IsValidEmail(email))
            return Result.Failure&lt;Email&gt;(&quot;Invalid email format&quot;);

        return Result.Success(new Email(email.ToLowerInvariant()));
    }

    private static bool IsValidEmail(string email)
    {
        return Regex.IsMatch(email, @&quot;^[^@\s]+@[^@\s]+\.[^@\s]+$&quot;);
    }
}

// Usage
var email1 = Email.Create(&quot;john@example.com&quot;).Value;
var email2 = Email.Create(&quot;john@example.com&quot;).Value;
// email1 == email2 (value equality)</code></pre>
<p><strong>Why:</strong> No identity, immutable, validated at creation, two identical emails are interchangeable.</p>
<p><strong>6. ProductReview - ENTITY</strong></p>
<pre class="language-csharp"><code class="language-csharp">public class ProductReview
{
    public Guid Id { get; private set; } // Identity
    public Guid ProductId { get; private set; }
    public Guid CustomerId { get; private set; }
    public int Rating { get; private set; }
    public string Comment { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime? UpdatedAt { get; private set; }
    public int HelpfulVotes { get; private set; }

    // Can be edited, votes can change
    public void Edit(int newRating, string newComment)
    {
        Rating = newRating;
        Comment = newComment;
        UpdatedAt = DateTime.UtcNow;
        // Still the same review!
    }

    public void AddHelpfulVote()
    {
        HelpfulVotes++;
    }
}</code></pre>
<p><strong>Why:</strong> Has identity, mutable, tracks who wrote it and when, can be edited, accumulates votes.</p>
<p><strong>7. DateRange - VALUE OBJECT</strong></p>
<pre class="language-csharp"><code class="language-csharp">public record DateRange
{
    public DateTime Start { get; }
    public DateTime End { get; }

    private DateRange(DateTime start, DateTime end)
    {
        Start = start;
        End = end;
    }

    public static Result&lt;DateRange&gt; Create(DateTime start, DateTime end)
    {
        if (start &gt; end)
            return Result.Failure&lt;DateRange&gt;(&quot;Start date must be before end date&quot;);

        return Result.Success(new DateRange(start, end));
    }

    public bool Contains(DateTime date)
    {
        return date &gt;= Start &amp;&amp; date &lt;= End;
    }

    public bool Overlaps(DateRange other)
    {
        return Start &lt;= other.End &amp;&amp; End &gt;= other.Start;
    }

    public int DurationInDays =&gt; (End - Start).Days;
}

// Usage
var range1 = DateRange.Create(DateTime.Today, DateTime.Today.AddDays(7)).Value;
var range2 = DateRange.Create(DateTime.Today, DateTime.Today.AddDays(7)).Value;
// range1 == range2 (value equality)</code></pre>
<p><strong>Why:</strong> No identity, immutable, defined by its values, provides behavior based on values.</p>
<p><strong>Summary:</strong></p>
<table><thead><tr><th>Concept</th><th>Type</th><th>Key Characteristic</th></tr></thead><tbody><tr><td>Customer</td><td>Entity</td><td>Has identity, mutable</td></tr><tr><td>Address</td><td>Value Object</td><td>No identity, immutable, value equality</td></tr><tr><td>Money</td><td>Value Object</td><td>No identity, immutable, mathematical operations</td></tr><tr><td>Order</td><td>Entity</td><td>Has identity, lifecycle, state changes</td></tr><tr><td>Email</td><td>Value Object</td><td>No identity, validated, immutable</td></tr><tr><td>ProductReview</td><td>Entity</td><td>Has identity, mutable, tracks authorship</td></tr><tr><td>DateRange</td><td>Value Object</td><td>No identity, immutable, defined by dates</td></tr></tbody></table>
<p><strong>Decision Criteria:</strong></p>
<ul><li><strong>Entity:</strong> Ask "Is this the same thing even if properties change?" → YES = Entity</li><li><strong>Value Object:</strong> Ask "Does identity matter or just the values?" → Values only = Value Object</li></ul>
<p></details></p>
<p>---</p>
<h3 id="exercise-11-implement-value-object-with-validation">Exercise 11: Implement Value Object with Validation</h3>
<p><strong>Question:</strong> Create a PhoneNumber value object with comprehensive validation and formatting.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">// Domain/ValueObjects/PhoneNumber.cs
public record PhoneNumber
{
    public string CountryCode { get; }
    public string Number { get; }
    public PhoneNumberType Type { get; }

    private PhoneNumber(string countryCode, string number, PhoneNumberType type)
    {
        CountryCode = countryCode;
        Number = number;
        Type = type;
    }

    public static Result&lt;PhoneNumber&gt; Create(
        string phoneNumber,
        PhoneNumberType type = PhoneNumberType.Mobile)
    {
        if (string.IsNullOrWhiteSpace(phoneNumber))
            return Result.Failure&lt;PhoneNumber&gt;(&quot;Phone number is required&quot;);

        // Remove formatting characters
        var cleaned = CleanPhoneNumber(phoneNumber);

        // Extract country code and number
        var (countryCode, number, error) = ExtractComponents(cleaned);
        if (error != null)
            return Result.Failure&lt;PhoneNumber&gt;(error);

        // Validate
        var validationError = Validate(countryCode, number);
        if (validationError != null)
            return Result.Failure&lt;PhoneNumber&gt;(validationError);

        return Result.Success(new PhoneNumber(countryCode, number, type));
    }

    private static string CleanPhoneNumber(string phoneNumber)
    {
        // Remove spaces, dashes, parentheses, etc.
        return Regex.Replace(phoneNumber, @&quot;[\s\-\(\)\.]&quot;, &quot;&quot;);
    }

    private static (string countryCode, string number, string error) ExtractComponents(string cleaned)
    {
        // Handle +1 (555) 123-4567 or 15551234567 or 5551234567
        if (cleaned.StartsWith(&quot;+&quot;))
        {
            cleaned = cleaned.Substring(1);
        }

        // USA/Canada (starts with 1)
        if (cleaned.StartsWith(&quot;1&quot;) &amp;&amp; cleaned.Length == 11)
        {
            return (&quot;+1&quot;, cleaned.Substring(1), null);
        }

        // Assume USA if 10 digits
        if (cleaned.Length == 10 &amp;&amp; cleaned.All(char.IsDigit))
        {
            return (&quot;+1&quot;, cleaned, null);
        }

        // Other countries - require + and country code
        if (cleaned.Length &gt; 10 &amp;&amp; cleaned.All(char.IsDigit))
        {
            // Extract first 1-3 digits as country code
            var countryCode = $&quot;+{cleaned.Substring(0, Math.Min(3, cleaned.Length))}&quot;;
            var number = cleaned.Substring(Math.Min(3, cleaned.Length));
            return (countryCode, number, null);
        }

        return (null, null, &quot;Invalid phone number format&quot;);
    }

    private static string Validate(string countryCode, string number)
    {
        if (!number.All(char.IsDigit))
            return &quot;Phone number must contain only digits&quot;;

        // USA/Canada validation
        if (countryCode == &quot;+1&quot;)
        {
            if (number.Length != 10)
                return &quot;USA/Canada phone numbers must be 10 digits&quot;;

            var areaCode = number.Substring(0, 3);
            var prefix = number.Substring(3, 3);

            // Area code can&#39;t start with 0 or 1
            if (areaCode[0] == &#39;0&#39; || areaCode[0] == &#39;1&#39;)
                return &quot;Invalid area code&quot;;

            // Prefix can&#39;t start with 0 or 1
            if (prefix[0] == &#39;0&#39; || prefix[0] == &#39;1&#39;)
                return &quot;Invalid prefix&quot;;
        }

        // General validation
        if (number.Length &lt; 7 || number.Length &gt; 15)
            return &quot;Phone number must be between 7 and 15 digits&quot;;

        return null;
    }

    // Formatted output
    public string ToFormattedString()
    {
        if (CountryCode == &quot;+1&quot; &amp;&amp; Number.Length == 10)
        {
            // Format as (555) 123-4567
            return $&quot;({Number.Substring(0, 3)}) {Number.Substring(3, 3)}-{Number.Substring(6)}&quot;;
        }

        return $&quot;{CountryCode} {Number}&quot;;
    }

    public string ToInternationalFormat()
    {
        return $&quot;{CountryCode}{Number}&quot;;
    }

    // Override ToString for display
    public override string ToString() =&gt; ToFormattedString();
}

// Domain/Enums/PhoneNumberType.cs
public enum PhoneNumberType
{
    Mobile,
    Home,
    Work,
    Fax
}

// Domain/ValueObjects/Result.cs (Helper)
public class Result&lt;T&gt;
{
    public bool IsSuccess { get; }
    public T Value { get; }
    public string Error { get; }

    private Result(bool isSuccess, T value, string error)
    {
        IsSuccess = isSuccess;
        Value = value;
        Error = error;
    }

    public static Result&lt;T&gt; Success(T value) =&gt; new(true, value, null);
    public static Result&lt;T&gt; Failure(string error) =&gt; new(false, default, error);
}

// Usage Examples
public class PhoneNumberExamples
{
    public void Examples()
    {
        // Valid formats
        var phone1 = PhoneNumber.Create(&quot;+1 (555) 123-4567&quot;);
        var phone2 = PhoneNumber.Create(&quot;555-123-4567&quot;);
        var phone3 = PhoneNumber.Create(&quot;15551234567&quot;);
        var phone4 = PhoneNumber.Create(&quot;+44 20 7946 0958&quot;, PhoneNumberType.Work);

        if (phone1.IsSuccess)
        {
            Console.WriteLine(phone1.Value.ToFormattedString()); // (555) 123-4567
            Console.WriteLine(phone1.Value.ToInternationalFormat()); // +15551234567
        }

        // Invalid formats
        var invalidPhone = PhoneNumber.Create(&quot;123&quot;); // Too short
        if (!invalidPhone.IsSuccess)
        {
            Console.WriteLine(invalidPhone.Error); // &quot;Phone number must be between 7 and 15 digits&quot;
        }

        // Value equality
        var phoneA = PhoneNumber.Create(&quot;555-123-4567&quot;).Value;
        var phoneB = PhoneNumber.Create(&quot;(555) 123-4567&quot;).Value;
        Console.WriteLine(phoneA == phoneB); // True - same values

        // Immutability - must create new instance
        var newPhone = PhoneNumber.Create(&quot;555-999-8888&quot;).Value;
        // Can&#39;t modify phoneA, must replace with newPhone
    }
}

// Entity using PhoneNumber value object
public class Customer
{
    public Guid Id { get; private set; }
    public string Name { get; private set; }
    public PhoneNumber MobilePhone { get; private set; }
    public PhoneNumber HomePhone { get; private set; }
    public PhoneNumber WorkPhone { get; private set; }

    public void UpdateMobilePhone(PhoneNumber newPhone)
    {
        if (newPhone.Type != PhoneNumberType.Mobile)
            throw new DomainException(&quot;Mobile phone must be of type Mobile&quot;);

        MobilePhone = newPhone;
    }

    public PhoneNumber GetPreferredPhone()
    {
        return MobilePhone ?? HomePhone ?? WorkPhone;
    }
}

// EF Core Configuration
public class CustomerConfiguration : IEntityTypeConfiguration&lt;Customer&gt;
{
    public void Configure(EntityTypeBuilder&lt;Customer&gt; builder)
    {
        // Value object as owned entity
        builder.OwnsOne(c =&gt; c.MobilePhone, phone =&gt;
        {
            phone.Property(p =&gt; p.CountryCode).HasColumnName(&quot;MobilePhoneCountryCode&quot;);
            phone.Property(p =&gt; p.Number).HasColumnName(&quot;MobilePhoneNumber&quot;);
            phone.Property(p =&gt; p.Type).HasColumnName(&quot;MobilePhoneType&quot;);
        });

        builder.OwnsOne(c =&gt; c.HomePhone, phone =&gt;
        {
            phone.Property(p =&gt; p.CountryCode).HasColumnName(&quot;HomePhoneCountryCode&quot;);
            phone.Property(p =&gt; p.Number).HasColumnName(&quot;HomePhoneNumber&quot;);
            phone.Property(p =&gt; p.Type).HasColumnName(&quot;HomePhoneType&quot;);
        });
    }
}

// Testing
public class PhoneNumberTests
{
    [Theory]
    [InlineData(&quot;+1 (555) 123-4567&quot;, true)]
    [InlineData(&quot;555-123-4567&quot;, true)]
    [InlineData(&quot;5551234567&quot;, true)]
    [InlineData(&quot;(555) 123-4567&quot;, true)]
    [InlineData(&quot;+44 20 7946 0958&quot;, true)]
    [InlineData(&quot;123&quot;, false)] // Too short
    [InlineData(&quot;abc-def-ghij&quot;, false)] // Not digits
    [InlineData(&quot;&quot;, false)] // Empty
    public void Create_ShouldValidatePhoneNumber(string input, bool shouldSucceed)
    {
        // Act
        var result = PhoneNumber.Create(input);

        // Assert
        Assert.Equal(shouldSucceed, result.IsSuccess);
    }

    [Fact]
    public void TwoPhoneNumbers_WithSameValue_ShouldBeEqual()
    {
        // Arrange
        var phone1 = PhoneNumber.Create(&quot;555-123-4567&quot;).Value;
        var phone2 = PhoneNumber.Create(&quot;(555) 123-4567&quot;).Value;

        // Assert
        Assert.Equal(phone1, phone2);
    }

    [Fact]
    public void PhoneNumber_ShouldFormatCorrectly()
    {
        // Arrange
        var phone = PhoneNumber.Create(&quot;5551234567&quot;).Value;

        // Assert
        Assert.Equal(&quot;(555) 123-4567&quot;, phone.ToFormattedString());
        Assert.Equal(&quot;+15551234567&quot;, phone.ToInternationalFormat());
    }
}</code></pre>
<p><strong>Key Features:</strong></p>
<ol><li>Immutable - uses record type</li><li>Self-validating - validation in Create method</li><li>No invalid state possible - private constructor</li><li>Value equality - records provide this automatically</li><li>Multiple formats - formatted output methods</li><li>Rich behavior - country code extraction, formatting</li><li>Returns Result<T> - explicit success/failure</li><li>EF Core integration - configured as owned entity</li></ol>
<p></details></p>
<p>---</p>
<p>(Continuing with more exercises... Due to length, I'll create the complete file)</p>
<p></details></p>
<p>---</p>
<h2 id="aggregate-design">Aggregate Design</h2>
<h3 id="exercise-12-design-an-aggregate">Exercise 12: Design an Aggregate</h3>
<p><strong>Question:</strong> Design an Order aggregate that maintains consistency across Order, OrderItems, and applies business rules.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">// Domain/Aggregates/OrderAggregate/Order.cs
public class Order : AggregateRoot
{
    public Guid Id { get; private set; }
    public string OrderNumber { get; private set; }
    public Guid CustomerId { get; private set; }

    private readonly List&lt;OrderItem&gt; _items = new();
    public IReadOnlyCollection&lt;OrderItem&gt; Items =&gt; _items.AsReadOnly();

    public OrderStatus Status { get; private set; }
    public DateTime PlacedAt { get; private set; }
    public Money Subtotal { get; private set; }
    public Money Tax { get; private set; }
    public Money Total { get; private set; }
    public Address ShippingAddress { get; private set; }

    // Aggregate invariant: Max 50 items per order
    private const int MaxItemsPerOrder = 50;

    // Aggregate invariant: Order must have at least one item to confirm
    private const int MinItemsToConfirm = 1;

    private Order() { } // EF Core

    public static Order Create(Guid customerId, Address shippingAddress)
    {
        var order = new Order
        {
            Id = Guid.NewGuid(),
            OrderNumber = GenerateOrderNumber(),
            CustomerId = customerId,
            Status = OrderStatus.Draft,
            PlacedAt = DateTime.UtcNow,
            ShippingAddress = shippingAddress ?? throw new ArgumentNullException(nameof(shippingAddress))
        };

        order.AddDomainEvent(new OrderCreatedEvent(order.Id, customerId));
        return order;
    }

    public void AddItem(Guid productId, string productName, Money unitPrice, int quantity)
    {
        // Enforce invariants
        if (Status != OrderStatus.Draft)
            throw new DomainException(&quot;Cannot add items to a non-draft order&quot;);

        if (_items.Count &gt;= MaxItemsPerOrder)
            throw new DomainException($&quot;Cannot add more than {MaxItemsPerOrder} items&quot;);

        // Check if item already exists
        var existingItem = _items.FirstOrDefault(i =&gt; i.ProductId == productId);
        if (existingItem != null)
        {
            existingItem.UpdateQuantity(existingItem.Quantity + quantity);
        }
        else
        {
            var item = OrderItem.Create(productId, productName, unitPrice, quantity);
            _items.Add(item);
        }

        RecalculateTotals();
        AddDomainEvent(new OrderItemAddedEvent(Id, productId, quantity));
    }

    public void RemoveItem(Guid itemId)
    {
        if (Status != OrderStatus.Draft)
            throw new DomainException(&quot;Cannot remove items from a non-draft order&quot;);

        var item = _items.FirstOrDefault(i =&gt; i.Id == itemId);
        if (item == null)
            throw new DomainException(&quot;Item not found&quot;);

        _items.Remove(item);
        RecalculateTotals();
        AddDomainEvent(new OrderItemRemovedEvent(Id, itemId));
    }

    public void UpdateItemQuantity(Guid itemId, int newQuantity)
    {
        if (Status != OrderStatus.Draft)
            throw new DomainException(&quot;Cannot update items in a non-draft order&quot;);

        var item = _items.FirstOrDefault(i =&gt; i.Id == itemId);
        if (item == null)
            throw new DomainException(&quot;Item not found&quot;);

        item.UpdateQuantity(newQuantity);
        RecalculateTotals();
    }

    public void Confirm()
    {
        // Enforce invariants
        if (Status != OrderStatus.Draft)
            throw new DomainException(&quot;Only draft orders can be confirmed&quot;);

        if (_items.Count &lt; MinItemsToConfirm)
            throw new DomainException(&quot;Order must have at least one item&quot;);

        Status = OrderStatus.Confirmed;
        PlacedAt = DateTime.UtcNow;
        AddDomainEvent(new OrderConfirmedEvent(Id, Total.Amount));
    }

    public void Cancel(string reason)
    {
        if (Status == OrderStatus.Shipped || Status == OrderStatus.Delivered)
            throw new DomainException(&quot;Cannot cancel a shipped or delivered order&quot;);

        if (Status == OrderStatus.Cancelled)
            throw new DomainException(&quot;Order is already cancelled&quot;);

        Status = OrderStatus.Cancelled;
        AddDomainEvent(new OrderCancelledEvent(Id, reason));
    }

    public void Ship(string trackingNumber)
    {
        if (Status != OrderStatus.Confirmed)
            throw new DomainException(&quot;Only confirmed orders can be shipped&quot;);

        if (string.IsNullOrWhiteSpace(trackingNumber))
            throw new ArgumentException(&quot;Tracking number is required&quot;);

        Status = OrderStatus.Shipped;
        AddDomainEvent(new OrderShippedEvent(Id, trackingNumber));
    }

    private void RecalculateTotals()
    {
        if (!_items.Any())
        {
            Subtotal = Money.Zero(&quot;USD&quot;);
            Tax = Money.Zero(&quot;USD&quot;);
            Total = Money.Zero(&quot;USD&quot;);
            return;
        }

        var subtotal = _items.Sum(i =&gt; i.LineTotal.Amount);
        Subtotal = new Money(subtotal, &quot;USD&quot;);

        // Calculate tax (8%)
        var taxAmount = subtotal * 0.08m;
        Tax = new Money(taxAmount, &quot;USD&quot;);

        Total = new Money(Subtotal.Amount + Tax.Amount, &quot;USD&quot;);
    }

    private static string GenerateOrderNumber()
    {
        return $&quot;ORD-{DateTime.UtcNow:yyyyMMdd}-{Guid.NewGuid().ToString().Substring(0, 8).ToUpper()}&quot;;
    }
}

// Domain/Aggregates/OrderAggregate/OrderItem.cs (Entity within aggregate)
public class OrderItem : Entity
{
    public Guid Id { get; private set; }
    public Guid ProductId { get; private set; }
    public string ProductName { get; private set; }
    public Money UnitPrice { get; private set; }
    public int Quantity { get; private set; }
    public Money LineTotal { get; private set; }

    private OrderItem() { }

    internal static OrderItem Create(Guid productId, string productName, Money unitPrice, int quantity)
    {
        if (quantity &lt;= 0)
            throw new DomainException(&quot;Quantity must be positive&quot;);

        var item = new OrderItem
        {
            Id = Guid.NewGuid(),
            ProductId = productId,
            ProductName = productName,
            UnitPrice = unitPrice,
            Quantity = quantity
        };

        item.CalculateLineTotal();
        return item;
    }

    internal void UpdateQuantity(int newQuantity)
    {
        if (newQuantity &lt;= 0)
            throw new DomainException(&quot;Quantity must be positive&quot;);

        Quantity = newQuantity;
        CalculateLineTotal();
    }

    private void CalculateLineTotal()
    {
        LineTotal = new Money(UnitPrice.Amount * Quantity, UnitPrice.Currency);
    }
}

// Domain/Common/AggregateRoot.cs
public abstract class AggregateRoot : Entity
{
    private readonly List&lt;IDomainEvent&gt; _domainEvents = new();
    public IReadOnlyList&lt;IDomainEvent&gt; DomainEvents =&gt; _domainEvents.AsReadOnly();

    protected void AddDomainEvent(IDomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }
}

// Application/UseCases/Orders/CreateOrder/CreateOrderHandler.cs
public class CreateOrderHandler
{
    private readonly IOrderRepository _orderRepository;
    private readonly IProductRepository _productRepository;

    public async Task&lt;Result&lt;Guid&gt;&gt; Handle(CreateOrderCommand command)
    {
        // Create aggregate
        var address = Address.Create(
            command.Street,
            command.City,
            command.State,
            command.ZipCode,
            command.Country
        );

        var order = Order.Create(command.CustomerId, address);

        // Add items
        foreach (var item in command.Items)
        {
            var product = await _productRepository.GetByIdAsync(item.ProductId);
            if (product == null)
                return Result.Failure&lt;Guid&gt;($&quot;Product {item.ProductId} not found&quot;);

            order.AddItem(
                product.Id,
                product.Name,
                product.Price,
                item.Quantity
            );
        }

        // Persist aggregate as a whole
        await _orderRepository.AddAsync(order);

        return Result.Success(order.Id);
    }
}</code></pre>
<p><strong>Aggregate Design Principles:</strong></p>
<ol><li>Order is the aggregate root</li><li>OrderItems are entities within the aggregate</li><li>Can only modify OrderItems through Order</li><li>All invariants enforced by Order</li><li>Changes to aggregate generate domain events</li><li>Repository operates on aggregate root</li><li>Transactional consistency within aggregate boundary</li></ol>
<p></details></p>
<p>---</p>
<h2 id="repository-pattern">Repository Pattern</h2>
<h3 id="exercise-13-implement-repository-pattern">Exercise 13: Implement Repository Pattern</h3>
<p><strong>Question:</strong> Implement a repository for the Order aggregate with proper abstraction.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">// Application/Interfaces/IOrderRepository.cs
public interface IOrderRepository
{
    Task&lt;Order&gt; GetByIdAsync(Guid id);
    Task&lt;Order&gt; GetByOrderNumberAsync(string orderNumber);
    Task&lt;IEnumerable&lt;Order&gt;&gt; GetByCustomerIdAsync(Guid customerId);
    Task&lt;IEnumerable&lt;Order&gt;&gt; GetPendingOrdersAsync();
    Task AddAsync(Order order);
    Task UpdateAsync(Order order);
    Task DeleteAsync(Guid id);
}

// Infrastructure/Persistence/OrderRepository.cs
public class OrderRepository : IOrderRepository
{
    private readonly ApplicationDbContext _context;
    private readonly IMediator _mediator;

    public OrderRepository(ApplicationDbContext context, IMediator mediator)
    {
        _context = context;
        _mediator = mediator;
    }

    public async Task&lt;Order&gt; GetByIdAsync(Guid id)
    {
        return await _context.Orders
            .Include(o =&gt; o.Items)
            .FirstOrDefaultAsync(o =&gt; o.Id == id);
    }

    public async Task&lt;Order&gt; GetByOrderNumberAsync(string orderNumber)
    {
        return await _context.Orders
            .Include(o =&gt; o.Items)
            .FirstOrDefaultAsync(o =&gt; o.OrderNumber == orderNumber);
    }

    public async Task&lt;IEnumerable&lt;Order&gt;&gt; GetByCustomerIdAsync(Guid customerId)
    {
        return await _context.Orders
            .Include(o =&gt; o.Items)
            .Where(o =&gt; o.CustomerId == customerId)
            .OrderByDescending(o =&gt; o.PlacedAt)
            .ToListAsync();
    }

    public async Task&lt;IEnumerable&lt;Order&gt;&gt; GetPendingOrdersAsync()
    {
        return await _context.Orders
            .Include(o =&gt; o.Items)
            .Where(o =&gt; o.Status == OrderStatus.Confirmed)
            .ToListAsync();
    }

    public async Task AddAsync(Order order)
    {
        await _context.Orders.AddAsync(order);
        await SaveChangesAndDispatchEventsAsync(order);
    }

    public async Task UpdateAsync(Order order)
    {
        _context.Orders.Update(order);
        await SaveChangesAndDispatchEventsAsync(order);
    }

    public async Task DeleteAsync(Guid id)
    {
        var order = await GetByIdAsync(id);
        if (order != null)
        {
            _context.Orders.Remove(order);
            await _context.SaveChangesAsync();
        }
    }

    private async Task SaveChangesAndDispatchEventsAsync(Order order)
    {
        await _context.SaveChangesAsync();

        // Dispatch domain events
        foreach (var domainEvent in order.DomainEvents)
        {
            await _mediator.Publish(domainEvent);
        }

        order.ClearDomainEvents();
    }
}</code></pre>
<p></details></p>
<p>---</p>
<h2 id="use-caseinteractor-implementation">Use Case/Interactor Implementation</h2>
<h3 id="exercise-14-cqrs-with-mediatr">Exercise 14: CQRS with MediatR</h3>
<p><strong>Question:</strong> Implement a complete use case for placing an order using CQRS pattern with MediatR.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">// Application/UseCases/Orders/PlaceOrder/PlaceOrderCommand.cs
public record PlaceOrderCommand(
    Guid CustomerId,
    Address ShippingAddress,
    List&lt;OrderItemDto&gt; Items
) : IRequest&lt;Result&lt;PlaceOrderResponse&gt;&gt;;

public record OrderItemDto(Guid ProductId, int Quantity);

public record PlaceOrderResponse(
    Guid OrderId,
    string OrderNumber,
    decimal TotalAmount
);

// Application/UseCases/Orders/PlaceOrder/PlaceOrderHandler.cs
public class PlaceOrderHandler : IRequestHandler&lt;PlaceOrderCommand, Result&lt;PlaceOrderResponse&gt;&gt;
{
    private readonly IOrderRepository _orderRepository;
    private readonly IProductRepository _productRepository;
    private readonly IInventoryService _inventoryService;
    private readonly ILogger&lt;PlaceOrderHandler&gt; _logger;

    public PlaceOrderHandler(
        IOrderRepository orderRepository,
        IProductRepository productRepository,
        IInventoryService inventoryService,
        ILogger&lt;PlaceOrderHandler&gt; logger)
    {
        _orderRepository = orderRepository;
        _productRepository = productRepository;
        _inventoryService = inventoryService;
        _logger = logger;
    }

    public async Task&lt;Result&lt;PlaceOrderResponse&gt;&gt; Handle(
        PlaceOrderCommand command,
        CancellationToken cancellationToken)
    {
        _logger.LogInformation(&quot;Placing order for customer {CustomerId}&quot;, command.CustomerId);

        // Create order aggregate
        var order = Order.Create(command.CustomerId, command.ShippingAddress);

        // Add items and check inventory
        foreach (var itemDto in command.Items)
        {
            var product = await _productRepository.GetByIdAsync(itemDto.ProductId);
            if (product == null)
            {
                _logger.LogWarning(&quot;Product {ProductId} not found&quot;, itemDto.ProductId);
                return Result.Failure&lt;PlaceOrderResponse&gt;($&quot;Product {itemDto.ProductId} not found&quot;);
            }

            // Check inventory
            var hasStock = await _inventoryService.CheckAvailabilityAsync(
                itemDto.ProductId,
                itemDto.Quantity
            );

            if (!hasStock)
            {
                _logger.LogWarning(&quot;Insufficient stock for product {ProductName}&quot;, product.Name);
                return Result.Failure&lt;PlaceOrderResponse&gt;($&quot;Insufficient stock for {product.Name}&quot;);
            }

            order.AddItem(product.Id, product.Name, product.Price, itemDto.Quantity);
        }

        // Confirm order
        order.Confirm();

        // Reserve inventory
        foreach (var item in order.Items)
        {
            await _inventoryService.ReserveStockAsync(item.ProductId, item.Quantity);
        }

        // Save
        await _orderRepository.AddAsync(order);

        _logger.LogInformation(
            &quot;Order {OrderNumber} placed successfully with total {Total}&quot;,
            order.OrderNumber,
            order.Total.Amount
        );

        return Result.Success(new PlaceOrderResponse(
            order.Id,
            order.OrderNumber,
            order.Total.Amount
        ));
    }
}

// Application/UseCases/Orders/PlaceOrder/PlaceOrderValidator.cs
public class PlaceOrderValidator : AbstractValidator&lt;PlaceOrderCommand&gt;
{
    public PlaceOrderValidator()
    {
        RuleFor(x =&gt; x.CustomerId)
            .NotEmpty().WithMessage(&quot;Customer ID is required&quot;);

        RuleFor(x =&gt; x.ShippingAddress)
            .NotNull().WithMessage(&quot;Shipping address is required&quot;);

        RuleFor(x =&gt; x.Items)
            .NotEmpty().WithMessage(&quot;Order must have at least one item&quot;)
            .Must(items =&gt; items.Count &lt;= 50).WithMessage(&quot;Order cannot have more than 50 items&quot;);

        RuleForEach(x =&gt; x.Items).ChildRules(item =&gt;
        {
            item.RuleFor(x =&gt; x.ProductId)
                .NotEmpty().WithMessage(&quot;Product ID is required&quot;);

            item.RuleFor(x =&gt; x.Quantity)
                .GreaterThan(0).WithMessage(&quot;Quantity must be positive&quot;)
                .LessThanOrEqualTo(100).WithMessage(&quot;Quantity cannot exceed 100&quot;);
        });
    }
}

// API/Controllers/OrdersController.cs
[ApiController]
[Route(&quot;api/[controller]&quot;)]
public class OrdersController : ControllerBase
{
    private readonly IMediator _mediator;

    public OrdersController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpPost]
    public async Task&lt;IActionResult&gt; PlaceOrder([FromBody] PlaceOrderRequest request)
    {
        var address = Address.Create(
            request.Street,
            request.City,
            request.State,
            request.ZipCode,
            request.Country
        );

        var command = new PlaceOrderCommand(
            request.CustomerId,
            address,
            request.Items.Select(i =&gt; new OrderItemDto(i.ProductId, i.Quantity)).ToList()
        );

        var result = await _mediator.Send(command);

        return result.IsSuccess
            ? Ok(result.Value)
            : BadRequest(new { error = result.Error });
    }
}</code></pre>
<p></details></p>
<p>---</p>
<h2 id="clean-architecture-in-aspnet-core">Clean Architecture in ASP.NET Core</h2>
<h3 id="exercise-15-configure-di-container">Exercise 15: Configure DI Container</h3>
<p><strong>Question:</strong> Set up the dependency injection container following Clean Architecture principles.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">// API/Program.cs
var builder = WebApplication.CreateBuilder(args);

// Add Application services
builder.Services.AddApplication();

// Add Infrastructure services
builder.Services.AddInfrastructure(builder.Configuration);

// Add Presentation services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();

// Application/DependencyInjection.cs
public static class DependencyInjection
{
    public static IServiceCollection AddApplication(this IServiceCollection services)
    {
        services.AddMediatR(cfg =&gt; {
            cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
        });

        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());

        services.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(ValidationBehavior&lt;,&gt;));
        services.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(LoggingBehavior&lt;,&gt;));

        services.AddAutoMapper(Assembly.GetExecutingAssembly());

        return services;
    }
}

// Infrastructure/DependencyInjection.cs
public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Database
        services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
            options.UseSqlServer(
                configuration.GetConnectionString(&quot;DefaultConnection&quot;),
                b =&gt; b.MigrationsAssembly(typeof(ApplicationDbContext).Assembly.FullName)
            )
        );

        // Repositories
        services.AddScoped&lt;IOrderRepository, OrderRepository&gt;();
        services.AddScoped&lt;IProductRepository, ProductRepository&gt;();
        services.AddScoped&lt;ICustomerRepository, CustomerRepository&gt;();

        // External Services
        services.AddScoped&lt;IEmailService, SmtpEmailService&gt;();
        services.AddScoped&lt;IPaymentGateway, StripePaymentAdapter&gt;();

        // Caching
        services.AddStackExchangeRedisCache(options =&gt;
        {
            options.Configuration = configuration.GetConnectionString(&quot;Redis&quot;);
        });

        return services;
    }
}</code></pre>
<p></details></p>
<p>---</p>
<h2 id="testing-strategies">Testing Strategies</h2>
<h3 id="exercise-16-unit-test-domain-logic">Exercise 16: Unit Test Domain Logic</h3>
<p><strong>Question:</strong> Write comprehensive unit tests for the Order aggregate.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">public class OrderTests
{
    [Fact]
    public void Create_ShouldCreateOrderInDraftStatus()
    {
        // Arrange
        var customerId = Guid.NewGuid();
        var address = CreateValidAddress();

        // Act
        var order = Order.Create(customerId, address);

        // Assert
        Assert.NotNull(order);
        Assert.Equal(customerId, order.CustomerId);
        Assert.Equal(OrderStatus.Draft, order.Status);
        Assert.Empty(order.Items);
    }

    [Fact]
    public void AddItem_ShouldAddItemToOrder()
    {
        // Arrange
        var order = CreateValidOrder();
        var productId = Guid.NewGuid();
        var price = new Money(10.00m, &quot;USD&quot;);

        // Act
        order.AddItem(productId, &quot;Product&quot;, price, 2);

        // Assert
        Assert.Single(order.Items);
        Assert.Equal(20.00m, order.Subtotal.Amount);
    }

    [Fact]
    public void Confirm_WithNoItems_ShouldThrowException()
    {
        // Arrange
        var order = CreateValidOrder();

        // Act &amp; Assert
        Assert.Throws&lt;DomainException&gt;(() =&gt; order.Confirm());
    }

    [Fact]
    public void AddItem_ToConfirmedOrder_ShouldThrowException()
    {
        // Arrange
        var order = CreateValidOrderWithItems();
        order.Confirm();

        // Act &amp; Assert
        Assert.Throws&lt;DomainException&gt;(() =&gt;
            order.AddItem(Guid.NewGuid(), &quot;Product&quot;, new Money(10, &quot;USD&quot;), 1)
        );
    }

    private Order CreateValidOrder()
    {
        return Order.Create(Guid.NewGuid(), CreateValidAddress());
    }

    private Address CreateValidAddress()
    {
        return Address.Create(&quot;123 Main St&quot;, &quot;City&quot;, &quot;State&quot;, &quot;12345&quot;, &quot;USA&quot;);
    }
}</code></pre>
<p></details></p>
<p>---</p>
<h2 id="cross-cutting-concerns">Cross-Cutting Concerns</h2>
<h3 id="exercise-17-add-a-validation-pipeline-behavior">Exercise 17: Add a Validation Pipeline Behavior</h3>
<p><strong>Question:</strong> Implement a MediatR pipeline behavior that runs FluentValidation before handlers.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">public class ValidationBehavior&lt;TRequest, TResponse&gt;
    : IPipelineBehavior&lt;TRequest, TResponse&gt;
{
    private readonly IEnumerable&lt;IValidator&lt;TRequest&gt;&gt; _validators;

    public ValidationBehavior(IEnumerable&lt;IValidator&lt;TRequest&gt;&gt; validators)
    {
        _validators = validators;
    }

    public async Task&lt;TResponse&gt; Handle(
        TRequest request,
        RequestHandlerDelegate&lt;TResponse&gt; next,
        CancellationToken ct)
    {
        if (_validators.Any())
        {
            var context = new ValidationContext&lt;TRequest&gt;(request);
            var results = await Task.WhenAll(
                _validators.Select(v =&gt; v.ValidateAsync(context, ct)));

            var failures = results.SelectMany(r =&gt; r.Errors)
                .Where(f =&gt; f != null)
                .ToList();

            if (failures.Count &gt; 0)
                throw new BadRequestException(&quot;Validation failed&quot;, failures);
        }

        return await next();
    }
}</code></pre>
<p>Register the behavior in the Application layer so validation is enforced consistently. </details></p>
<p>---</p>
<h3 id="exercise-18-add-logging-around-use-cases">Exercise 18: Add Logging Around Use Cases</h3>
<p><strong>Question:</strong> Add structured logging around a use case without polluting domain code.</p>
<p><details> <summary>Answer</summary></p>
<p>Use a pipeline behavior or decorator:</p>
<pre class="language-csharp"><code class="language-csharp">public class LoggingBehavior&lt;TRequest, TResponse&gt;
    : IPipelineBehavior&lt;TRequest, TResponse&gt;
{
    private readonly ILogger&lt;LoggingBehavior&lt;TRequest, TResponse&gt;&gt; _logger;

    public LoggingBehavior(ILogger&lt;LoggingBehavior&lt;TRequest, TResponse&gt;&gt; logger)
    {
        _logger = logger;
    }

    public async Task&lt;TResponse&gt; Handle(
        TRequest request,
        RequestHandlerDelegate&lt;TResponse&gt; next,
        CancellationToken ct)
    {
        _logger.LogInformation(&quot;Handling {Request}&quot;, typeof(TRequest).Name);
        var response = await next();
        _logger.LogInformation(&quot;Handled {Request}&quot;, typeof(TRequest).Name);
        return response;
    }
}</code></pre>
<p>This keeps cross-cutting concerns out of domain entities and handlers. </details></p>
<p>---</p>
<h3 id="exercise-19-cache-aside-decorator">Exercise 19: Cache-Aside Decorator</h3>
<p><strong>Question:</strong> Add a cache decorator for a query handler without changing the handler logic.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">public class CachedGetOrderHandler
    : IRequestHandler&lt;GetOrderQuery, OrderDto&gt;
{
    private readonly IRequestHandler&lt;GetOrderQuery, OrderDto&gt; _inner;
    private readonly ICache _cache;

    public CachedGetOrderHandler(
        IRequestHandler&lt;GetOrderQuery, OrderDto&gt; inner,
        ICache cache)
    {
        _inner = inner;
        _cache = cache;
    }

    public async Task&lt;OrderDto&gt; Handle(GetOrderQuery request, CancellationToken ct)
    {
        var key = $&quot;order:{request.Id}&quot;;
        if (_cache.TryGet(key, out OrderDto cached))
            return cached;

        var result = await _inner.Handle(request, ct);
        _cache.Set(key, result, TimeSpan.FromMinutes(5));
        return result;
    }
}</code></pre>
<p>Register the decorator in the composition root. </details></p>
<p>---</p>
<h2 id="integration-boundaries">Integration Boundaries</h2>
<h3 id="exercise-20-anti-corruption-layer">Exercise 20: Anti-Corruption Layer</h3>
<p><strong>Question:</strong> Wrap an external pricing API so its model does not leak into your domain.</p>
<p><details> <summary>Answer</summary></p>
<p>Create an adapter in Infrastructure and map to domain models:</p>
<pre class="language-csharp"><code class="language-csharp">public interface IPriceFeed
{
    Task&lt;PriceQuote&gt; GetQuoteAsync(Symbol symbol, CancellationToken ct);
}

public class ExternalPriceFeedAdapter : IPriceFeed
{
    private readonly ExternalClient _client;

    public async Task&lt;PriceQuote&gt; GetQuoteAsync(Symbol symbol, CancellationToken ct)
    {
        var response = await _client.GetQuoteAsync(symbol.Value, ct);
        return new PriceQuote(symbol, response.Bid, response.Ask, response.Timestamp);
    }
}</code></pre>
<p>The domain sees only <code>PriceQuote</code>, not the external DTOs. </details></p>
<p>---</p>
<h3 id="exercise-21-domain-events-vs-integration-events">Exercise 21: Domain Events vs Integration Events</h3>
<p><strong>Question:</strong> Distinguish domain events from integration events and place them in the correct layer.</p>
<p><details> <summary>Answer</summary></p>
<p>Domain events live in the Domain layer and capture business facts. Integration events live in Application/Infrastructure and are published externally.</p>
<pre class="language-csharp"><code class="language-csharp">// Domain
public record OrderConfirmedEvent(Guid OrderId) : IDomainEvent;

// Application/Infrastructure
public record OrderConfirmedIntegrationEvent(Guid OrderId, DateTime OccurredAt);</code></pre>
<p>Map domain events to integration events in Application/Infrastructure. </details></p>
<p>---</p>
<h3 id="exercise-22-outbox-pattern-placement">Exercise 22: Outbox Pattern Placement</h3>
<p><strong>Question:</strong> Where does the outbox belong, and how does it flow?</p>
<p><details> <summary>Answer</summary></p>
<p>The outbox is Infrastructure (storage) with orchestration in Application. The Application persists domain changes and an outbox record in the same transaction, then Infrastructure publishes. </details></p>
<p>---</p>
<h3 id="exercise-23-external-api-retry-policy">Exercise 23: External API Retry Policy</h3>
<p><strong>Question:</strong> Add Polly retries to an external adapter without leaking to use cases.</p>
<p><details> <summary>Answer</summary></p>
<p>Wrap the HTTP client in Infrastructure:</p>
<pre class="language-csharp"><code class="language-csharp">services.AddHttpClient&lt;IPriceFeed, ExternalPriceFeedAdapter&gt;()
    .AddTransientHttpErrorPolicy(p =&gt; p.WaitAndRetryAsync(3, i =&gt; TimeSpan.FromMilliseconds(200 * i)));</code></pre>
<p>Use cases still depend only on <code>IPriceFeed</code>. </details></p>
<p>---</p>
<h2 id="operational-concerns">Operational Concerns</h2>
<h3 id="exercise-24-centralized-error-handling">Exercise 24: Centralized Error Handling</h3>
<p><strong>Question:</strong> Implement middleware that converts exceptions to ProblemDetails.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">app.UseMiddleware&lt;ExceptionMiddleware&gt;();</code></pre>
<p>Keep exception types in Application/Domain and translate at the API boundary. </details></p>
<p>---</p>
<h3 id="exercise-25-configuration-via-options">Exercise 25: Configuration via Options</h3>
<p><strong>Question:</strong> Inject configuration into Infrastructure using the options pattern.</p>
<p><details> <summary>Answer</summary></p>
<pre class="language-csharp"><code class="language-csharp">builder.Services.Configure&lt;EmailSettings&gt;(
    builder.Configuration.GetSection(&quot;Email&quot;));

builder.Services.AddTransient&lt;IEmailService, SmtpEmailService&gt;();</code></pre>
<p>Options live in Infrastructure; Application depends only on interfaces. </details></p>
<p>---</p>
<h3 id="exercise-26-multi-tenancy-context">Exercise 26: Multi-Tenancy Context</h3>
<p><strong>Question:</strong> Introduce tenant context without leaking HTTP concerns into Application.</p>
<p><details> <summary>Answer</summary></p>
<p>Define <code>ITenantContext</code> in Application and implement in API/Infrastructure:</p>
<pre class="language-csharp"><code class="language-csharp">public interface ITenantContext
{
    string TenantId { get; }
}</code></pre>
<p>Use middleware to set it per request. </details></p>
<p>---</p>
<h3 id="exercise-27-background-jobs-in-clean-architecture">Exercise 27: Background Jobs in Clean Architecture</h3>
<p><strong>Question:</strong> Place a scheduled job that reconciles trades each night.</p>
<p><details> <summary>Answer</summary></p>
<p>Implement <code>IHostedService</code> in Infrastructure or API and call Application use cases:</p>
<pre class="language-csharp"><code class="language-csharp">public class ReconciliationJob : BackgroundService
{
    private readonly IMediator _mediator;

    protected override Task ExecuteAsync(CancellationToken ct) =&gt;
        _mediator.Send(new ReconcileTradesCommand(), ct);
}</code></pre>
<p>The job is orchestration; business logic stays in Application/Domain. </details></p>
<p>---</p>
<h3 id="exercise-28-use-a-clock-abstraction">Exercise 28: Use a Clock Abstraction</h3>
<p><strong>Question:</strong> Avoid <code>DateTime.UtcNow</code> in domain logic.</p>
<p><details> <summary>Answer</summary></p>
<p>Define <code>IClock</code> in Application and inject:</p>
<pre class="language-csharp"><code class="language-csharp">public interface IClock { DateTime UtcNow { get; } }</code></pre>
<p>This improves testability and deterministic behavior. </details></p>
<p>---</p>
<h2 id="refactoring-migration">Refactoring & Migration</h2>
<h3 id="exercise-29-feature-slice-vs-layered-folders">Exercise 29: Feature-Slice vs Layered Folders</h3>
<p><strong>Question:</strong> Compare organizing Application by feature vs by technical layer.</p>
<p><details> <summary>Answer</summary></p>
<p>Feature slices keep commands, handlers, DTOs, and validators together per use case, reducing cross-folder navigation. Layered folders can scale but often scatter related files. </details></p>
<p>---</p>
<h3 id="exercise-30-introduce-clean-architecture-gradually">Exercise 30: Introduce Clean Architecture Gradually</h3>
<p><strong>Question:</strong> Sketch steps to migrate a legacy MVC app to Clean Architecture.</p>
<p><details> <summary>Answer</summary></p>
<p>Start by extracting Domain models, then add Application use cases, then move data access to Infrastructure and keep controllers thin. Migrate per feature to reduce risk. </details></p>
<p>---</p>
<h3 id="exercise-31-avoid-the-anemic-domain">Exercise 31: Avoid the Anemic Domain</h3>
<p><strong>Question:</strong> Refactor an anemic entity into a richer domain model.</p>
<p><details> <summary>Answer</summary></p>
<p>Move invariants into entity methods, make setters private, and expose behaviors like <code>Confirm()</code> or <code>ReserveStock()</code> instead of raw property changes. </details></p>
<p>---</p>
<h3 id="exercise-32-dto-mapping-boundaries">Exercise 32: DTO Mapping Boundaries</h3>
<p><strong>Question:</strong> Decide where mapping belongs and justify it.</p>
<p><details> <summary>Answer</summary></p>
<p>Map at the Application boundary (handlers) so Domain remains pure and Presentation stays thin. Avoid passing DTOs into Domain. </details></p>
<p>---</p>
<h3 id="exercise-33-versioning-use-cases">Exercise 33: Versioning Use Cases</h3>
<p><strong>Question:</strong> Support breaking changes in commands without duplicating infrastructure.</p>
<p><details> <summary>Answer</summary></p>
<p>Create a new command/handler version and map from v1/v2 API models. Keep shared domain logic in services or domain entities. </details></p>
<p>---</p>
<h3 id="exercise-34-modular-monolith-boundaries">Exercise 34: Modular Monolith Boundaries</h3>
<p><strong>Question:</strong> Define a module boundary for trading and risk in the same codebase.</p>
<p><details> <summary>Answer</summary></p>
<p>Use separate Application/Domain namespaces per module, restrict references via project files, and communicate via events or interfaces to avoid direct coupling. </details></p>
<p>---</p>
<h3 id="exercise-35-define-a-unit-of-work">Exercise 35: Define a Unit of Work</h3>
<p><strong>Question:</strong> Explain where Unit of Work belongs and how it is used.</p>
<p><details> <summary>Answer</summary></p>
<p>The interface lives in Application, implementation in Infrastructure. Handlers coordinate repository changes and call <code>SaveChangesAsync</code> once per use case. </details></p>
      </article>
    </main>
  </div>
  <footer class="footer">Built for disciplined study & interview drills.</footer>
  <script>
    (() => {
      const select = document.getElementById('theme-select');
      const supported = ['dark2', 'light', 'dark'];
      const saved = sessionStorage.getItem('study-theme');
      const normalized = saved === 'midnight' ? 'dark2' : saved;
      const fallback = 'light';
      const initial = supported.includes(normalized) ? normalized : (window.__studyTheme || fallback);
      document.documentElement.dataset.theme = initial;
      if (select) {
        select.value = initial;
        select.addEventListener('change', (event) => {
          const value = event.target.value;
          const next = supported.includes(value) ? value : fallback;
          document.documentElement.dataset.theme = next;
          sessionStorage.setItem('study-theme', next);
        });
      }
    })();
    (() => {
      const groups = document.querySelectorAll('.sidebar-group');
      if (!groups.length) return;
      const storageKey = 'study-open-groups';
      const saved = sessionStorage.getItem(storageKey);
      const openFromStorage = new Set(saved ? JSON.parse(saved) : []);

      const activeLink = document.querySelector('.nav-link.active');
      const activeGroup = activeLink?.closest('.sidebar-group');
      if (activeGroup?.dataset.group) {
        openFromStorage.add(activeGroup.dataset.group);
      }

      const syncStorage = () => {
        const openIds = Array.from(document.querySelectorAll('.sidebar-group.is-open'))
          .map((group) => group.dataset.group)
          .filter(Boolean);
        sessionStorage.setItem(storageKey, JSON.stringify(openIds));
      };

      const setExpanded = (group, expanded) => {
        const header = group.querySelector('.sidebar-group__header');
        const list = group.querySelector('.sidebar-group__items');
        group.classList.toggle('is-open', expanded);
        header?.setAttribute('aria-expanded', expanded);
        if (list) {
          list.hidden = !expanded;
        }
      };

      groups.forEach((group) => {
        const shouldOpen = openFromStorage.has(group.dataset.group);
        setExpanded(group, shouldOpen);
        const header = group.querySelector('.sidebar-group__header');
        header?.addEventListener('click', () => {
          const next = !group.classList.contains('is-open');
          setExpanded(group, next);
          syncStorage();
        });
      });
    })();
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        const swPath = '..\../service-worker.js';
        navigator.serviceWorker.register(swPath).catch((err) => {
          console.error('Service worker registration failed', err);
        });
      });
    }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
</body>
</html>