<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Senior .NET study guide for ON Linear Time Exercises" />
  <meta name="theme-color" content="#0f172a" />
  <title>ON Linear Time Exercises | C# Interview Prep Cheat Sheet</title>
  <link rel="manifest" href="..\..\assets/manifest.webmanifest" />
  <script>
    (() => {
      const supported = ['dark2', 'light', 'dark'];
      const saved = sessionStorage.getItem('study-theme');
      const normalized = saved === 'midnight' ? 'dark2' : saved;
      const fallback = 'light';
      const initial = supported.includes(normalized) ? normalized : fallback;
      document.documentElement.dataset.theme = initial;
      window.__studyTheme = initial;
    })();
  </script>
  <link rel="stylesheet" href="..\..\assets/styles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <div>
      <p class="eyebrow">C# Interview Prep</p>
      <h1>Senior .NET Study Portal</h1>
      <p class="subtitle">Ultimate cheat sheets, patterns, and interview-ready scenarios in one place.</p>
    </div>
    <div class="header-actions">
      <div class="theme-switcher" aria-label="Theme selector">
        <label for="theme-select" class="theme-label">Theme</label>
        <select id="theme-select" class="theme-select">
          <option value="dark2">Dark 2</option>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
      <div class="badge">Fast recall</div>
    </div>
  </header>
  <div class="layout">
    <nav class="sidebar">
      <div class="sidebar-section">
        <h2>Navigation</h2>
        <div class="search-hint">Use Ctrl/Cmd + F for quick lookup</div>
        <div class="sidebar-scroll"><div class="nav-groups"><div class="sidebar-group" data-group="notes">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/core-concepts.html">Core Concepts</a></li><li><a class="nav-link" href="..\../notes/defensive-programming-vs-fail-fast.html">Defensive Programming Vs Fail Fast</a></li><li><a class="nav-link" href="..\../notes/error-handling.html">Error Handling</a></li><li><a class="nav-link" href="..\../notes/logging.html">Logging</a></li><li><a class="nav-link" href="..\../notes/solution-architecture.html">Solution Architecture</a></li><li><a class="nav-link" href="..\../notes/sse-vs-websockets.html">Sse Vs Websockets</a></li><li><a class="nav-link" href="..\../notes/system-architecture.html">System Architecture</a></li><li><a class="nav-link" href="..\../notes/testing-strategies.html">Testing Strategies</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-automapper">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Automapper</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Automapper/AutoMapper.html">AutoMapper</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-big-o-complexity">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Big O Complexity</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Big-O-Complexity/index.html">Big O Complexity</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/O1-Constant-Time.html">O1 Constant Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/OLogN-Logarithmic-Time.html">OLogN Logarithmic Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/ON-Linear-Time.html">ON Linear Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/ON2-Quadratic-Time.html">ON2 Quadratic Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/ONLogN-Linearithmic-Time.html">ONLogN Linearithmic Time</a></li><li><a class="nav-link" href="..\../notes/Big-O-Complexity/Space-Complexity.html">Space Complexity</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-clean-architecture">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Clean Architecture</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Clean-Architecture/index.html">Clean Architecture</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-collections-and-enumerables">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Collections And Enumerables</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/index.html">Collections And Enumerables</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/ICollection.html">ICollection</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/IEnumerable.html">IEnumerable</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/IList.html">IList</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/IQueryable.html">IQueryable</a></li><li><a class="nav-link" href="..\../notes/Collections-And-Enumerables/IReadOnly.html">IReadOnly</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-design-patterns">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Design Patterns</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Design-Patterns/CQRS Pattern.html">CQRS Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Decorator Pattern.html">Decorator Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Factory Pattern.html">Factory Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Mediator Pattern.html">Mediator Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Observer Pattern.html">Observer Pattern</a></li><li><a class="nav-link" href="..\../notes/Design-Patterns/Strategy Pattern.html">Strategy Pattern</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-dry">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / DRY</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/DRY/index.html">DRY</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-fluentvalidation">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / FluentValidation</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/FluentValidation/FluentValidation.html">FluentValidation</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-memory-allocation-discipline">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Memory Allocation Discipline</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Memory-Allocation-Discipline/index.html">Memory Allocation Discipline</a></li><li><a class="nav-link" href="..\../notes/Memory-Allocation-Discipline/Memory Allocation Discipline Example.html">Memory Allocation Discipline Example</a></li><li><a class="nav-link" href="..\../notes/Memory-Allocation-Discipline/Memory Allocation Discipline Example Async.html">Memory Allocation Discipline Example Async</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-solid">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / SOLID</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/SOLID/D-Dependency-Inversion-Principle-DIP.html">D Dependency Inversion Principle DIP</a></li><li><a class="nav-link" href="..\../notes/SOLID/I-Interface-Segregation-Principle-ISP.html">I Interface Segregation Principle ISP</a></li><li><a class="nav-link" href="..\../notes/SOLID/L-Liskov-Substitution-Principle-LSP.html">L Liskov Substitution Principle LSP</a></li><li><a class="nav-link" href="..\../notes/SOLID/O-Open-Closed-Principle-OCP.html">O Open Closed Principle OCP</a></li><li><a class="nav-link" href="..\../notes/SOLID/S-Single-Responsibility-Principle-SRP.html">S Single Responsibility Principle SRP</a></li><li><a class="nav-link" href="..\../notes/SOLID/index.html">SOLID</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-sub-notes">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Sub Notes</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/sub-notes/Async Await Deep Dive.html">Async Await Deep Dive</a></li><li><a class="nav-link" href="..\../notes/sub-notes/base-keyword.html">Base Keyword</a></li><li><a class="nav-link" href="..\../notes/sub-notes/CLR & Garbage Collector (GC).html">CLR & Garbage Collector (GC)</a></li><li><a class="nav-link" href="..\../notes/sub-notes/CLR & Garbage Collector (GC) Practical Example.html">CLR & Garbage Collector (GC) Practical Example</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Dependency Injection Lifetimes.html">Dependency Injection Lifetimes</a></li><li><a class="nav-link" href="..\../notes/sub-notes/FIFO Queues in .NET.html">FIFO Queues In .NET</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Forcing Garbage Collection.html">Forcing Garbage Collection</a></li><li><a class="nav-link" href="..\../notes/sub-notes/IDisposable Patterns.html">IDisposable Patterns</a></li><li><a class="nav-link" href="..\../notes/sub-notes/nameof-keyword.html">Nameof Keyword</a></li><li><a class="nav-link" href="..\../notes/sub-notes/NET Generational Garbage Collection (GC) Deep Dive.html">NET Generational Garbage Collection (GC) Deep Dive</a></li><li><a class="nav-link" href="..\../notes/sub-notes/RabbitMQ.html">RabbitMQ</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Reflection Overview.html">Reflection Overview</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Server vs Workstation GC.html">Server Vs Workstation GC</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Sorted Collections Interview Notes.html">Sorted Collections Interview Notes</a></li><li><a class="nav-link" href="..\../notes/sub-notes/Sorting Algorithms.html">Sorting Algorithms</a></li><li><a class="nav-link" href="..\../notes/sub-notes/struct vs class when to use which.html">Struct Vs Class When To Use Which</a></li><li><a class="nav-link" href="..\../notes/sub-notes/types.html">Types</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-tech-stacks">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Tech Stacks</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Tech-Stacks/index.html">Tech Stacks</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-tech-stacks-golang">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Tech Stacks / GoLang</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Tech-Stacks/GoLang/index.html">GoLang</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-tech-stacks-react">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Tech Stacks / React</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Tech-Stacks/React/index.html">React</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-tech-stacks-stack-pairings">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Tech Stacks / Stack Pairings</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Tech-Stacks/Stack-Pairings/index.html">Stack Pairings</a></li></ul>
    </div><div class="sidebar-group" data-group="notes-use-cases-massive-traffic">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Notes / Use Cases / Massive Traffic</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/01-async-patterns.html">01 Async Patterns</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/02-backpressure-rate-limiting.html">02 Backpressure Rate Limiting</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/03-caching-strategies.html">03 Caching Strategies</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/04-database-scaling.html">04 Database Scaling</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/05-message-queues.html">05 Message Queues</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/06-resilience-patterns.html">06 Resilience Patterns</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/07-observability.html">07 Observability</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/08-complete-example.html">08 Complete Example</a></li><li><a class="nav-link" href="..\../notes/Use-Cases/massive-traffic/index.html">Massive Traffic</a></li></ul>
    </div><div class="sidebar-group" data-group="practice">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/answers.html">Answers</a></li><li><a class="nav-link" href="..\../practice/core-concepts.html">Core Concepts</a></li><li><a class="nav-link" href="..\../practice/defensive-programming-vs-fail-fast-exercises.html">Defensive Programming Vs Fail Fast Exercises</a></li><li><a class="nav-link" href="..\../practice/error-handling-exercises.html">Error Handling Exercises</a></li><li><a class="nav-link" href="..\../practice/logging-exercises.html">Logging Exercises</a></li><li><a class="nav-link" href="..\../practice/index.html">Practice</a></li><li><a class="nav-link" href="..\../practice/PRACTICE-STRUCTURE.html">PRACTICE STRUCTURE</a></li><li><a class="nav-link" href="..\../practice/questions.html">Questions</a></li><li><a class="nav-link" href="..\../practice/README.html">README</a></li><li><a class="nav-link" href="..\../practice/solution-architecture-exercises.html">Solution Architecture Exercises</a></li><li><a class="nav-link" href="..\../practice/sse-vs-websockets-exercises.html">Sse Vs Websockets Exercises</a></li><li><a class="nav-link" href="..\../practice/system-architecture-exercises.html">System Architecture Exercises</a></li><li><a class="nav-link" href="..\../practice/testing-strategies-exercises.html">Testing Strategies Exercises</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-automapper">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Automapper</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Automapper/index.html">Automapper</a></li></ul>
    </div><div class="sidebar-group is-open" data-group="practice-big-o-complexity">
      <button class="sidebar-group__header" type="button" aria-expanded="true">
        <span>Practice / Big O Complexity</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items"><li><a class="nav-link" href="..\../practice/Big-O-Complexity/index.html">Big O Complexity</a></li><li><a class="nav-link" href="..\../practice/Big-O-Complexity/O1-Constant-Time-Exercises.html">O1 Constant Time Exercises</a></li><li><a class="nav-link" href="..\../practice/Big-O-Complexity/OLogN-Logarithmic-Time-Exercises.html">OLogN Logarithmic Time Exercises</a></li><li><a class="nav-link active" href="..\../practice/Big-O-Complexity/ON-Linear-Time-Exercises.html">ON Linear Time Exercises</a></li><li><a class="nav-link" href="..\../practice/Big-O-Complexity/ON2-Quadratic-Time-Exercises.html">ON2 Quadratic Time Exercises</a></li><li><a class="nav-link" href="..\../practice/Big-O-Complexity/ONLogN-Linearithmic-Time-Exercises.html">ONLogN Linearithmic Time Exercises</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-clean-architecture">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Clean Architecture</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Clean-Architecture/index.html">Clean Architecture</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-collections-and-enumerables">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Collections And Enumerables</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Collections-And-Enumerables/index.html">Collections And Enumerables</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-design-patterns">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Design Patterns</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Design-Patterns/Decorator-Pattern-Exercises.html">Decorator Pattern Exercises</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/index.html">Design Patterns</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/Factory-Pattern-Exercises.html">Factory Pattern Exercises</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/Mediator-Pattern-Exercises.html">Mediator Pattern Exercises</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/Observer-Pattern-Exercises.html">Observer Pattern Exercises</a></li><li><a class="nav-link" href="..\../practice/Design-Patterns/Strategy-Pattern-Exercises.html">Strategy Pattern Exercises</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-dry">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / DRY</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/DRY/index.html">DRY</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-fluentvalidation">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / FluentValidation</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/FluentValidation/index.html">FluentValidation</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-memory-allocation-discipline">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Memory Allocation Discipline</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Memory-Allocation-Discipline/index.html">Memory Allocation Discipline</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-solid">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / SOLID</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/SOLID/S-Single-Responsibility-Principle-Exercises.html">S Single Responsibility Principle Exercises</a></li><li><a class="nav-link" href="..\../practice/SOLID/index.html">SOLID</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-sub-notes">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Sub Notes</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/sub-notes/api-lifecycle.html">Api Lifecycle</a></li><li><a class="nav-link" href="..\../practice/sub-notes/async-await-exercises.html">Async Await Exercises</a></li><li><a class="nav-link" href="..\../practice/sub-notes/async-resilience.html">Async Resilience</a></li><li><a class="nav-link" href="..\../practice/sub-notes/behavioral-questions.html">Behavioral Questions</a></li><li><a class="nav-link" href="..\../practice/sub-notes/code-assessment.html">Code Assessment</a></li><li><a class="nav-link" href="..\../practice/sub-notes/csharp-fundamentals.html">Csharp Fundamentals</a></li><li><a class="nav-link" href="..\../practice/sub-notes/csharp-system-design-questions.html">Csharp System Design Questions</a></li><li><a class="nav-link" href="..\../practice/sub-notes/data-layer.html">Data Layer</a></li><li><a class="nav-link" href="..\../practice/sub-notes/linq-collections.html">Linq Collections</a></li><li><a class="nav-link" href="..\../practice/sub-notes/messaging-integration.html">Messaging Integration</a></li><li><a class="nav-link" href="..\../practice/sub-notes/performance-memory.html">Performance Memory</a></li><li><a class="nav-link" href="..\../practice/sub-notes/replace int without variable.html">Replace Int Without Variable</a></li><li><a class="nav-link" href="..\../practice/sub-notes/struct vs class questions and answers.html">Struct Vs Class Questions And Answers</a></li><li><a class="nav-link" href="..\../practice/sub-notes/system-design.html">System Design</a></li><li><a class="nav-link" href="..\../practice/sub-notes/trading-domain.html">Trading Domain</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-tech-stacks">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Tech Stacks</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Tech-Stacks/index.html">Tech Stacks</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-tech-stacks-golang">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Tech Stacks / GoLang</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Tech-Stacks/GoLang/index.html">GoLang</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-tech-stacks-react">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Tech Stacks / React</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Tech-Stacks/React/index.html">React</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-tech-stacks-stack-pairings">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Tech Stacks / Stack Pairings</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Tech-Stacks/Stack-Pairings/index.html">Stack Pairings</a></li></ul>
    </div><div class="sidebar-group" data-group="practice-use-cases-massive-traffic">
      <button class="sidebar-group__header" type="button" aria-expanded="false">
        <span>Practice / Use Cases / Massive Traffic</span>
        <span class="chevron" aria-hidden="true"></span>
      </button>
      <ul class="sidebar-group__items" hidden><li><a class="nav-link" href="..\../practice/Use-Cases/massive-traffic/index.html">Massive Traffic</a></li></ul>
    </div></div></div>
      </div>
    </nav>
    <main class="content">
      <article class="card">
        <div class="breadcrumbs">practice\Big-O-Complexity\ON-Linear-Time-Exercises.md</div>
        <h2>ON Linear Time Exercises</h2>
        <div class="toc-label">Rapid overview</div>
        <div class="toc"><ul class="toc-list"><li class="level-1"><a href="#on---linear-time-complexity-exercises">O(n) - Linear Time Complexity Exercises</a></li><li class="level-2"><a href="#overview">Overview</a></li><li class="level-2"><a href="#exercise-1-linear-search">Exercise 1: Linear Search</a></li><li class="level-2"><a href="#exercise-2-find-minimummaximum">Exercise 2: Find Minimum/Maximum</a></li><li class="level-2"><a href="#exercise-3-sum-of-array-elements">Exercise 3: Sum of Array Elements</a></li><li class="level-2"><a href="#exercise-4-reverse-an-array-in-place">Exercise 4: Reverse an Array In-Place</a></li><li class="level-2"><a href="#exercise-5-remove-duplicates-from-sorted-array">Exercise 5: Remove Duplicates from Sorted Array</a></li><li class="level-2"><a href="#exercise-6-count-occurrences">Exercise 6: Count Occurrences</a></li><li class="level-2"><a href="#exercise-7-two-sum-hash-map-approach">Exercise 7: Two Sum (Hash Map Approach)</a></li><li class="level-2"><a href="#exercise-8-move-zeros-to-end">Exercise 8: Move Zeros to End</a></li><li class="level-2"><a href="#exercise-9-contains-duplicate-hash-set">Exercise 9: Contains Duplicate (Hash Set)</a></li><li class="level-2"><a href="#exercise-10-merge-two-sorted-arrays">Exercise 10: Merge Two Sorted Arrays</a></li><li class="level-2"><a href="#exercise-11-valid-palindrome">Exercise 11: Valid Palindrome</a></li><li class="level-2"><a href="#exercise-12-longest-substring-without-repeating-characters">Exercise 12: Longest Substring Without Repeating Characters</a></li><li class="level-2"><a href="#exercise-13-maximum-subarray-sum-kadanes-algorithm">Exercise 13: Maximum Subarray Sum (Kadane's Algorithm)</a></li><li class="level-2"><a href="#exercise-14-best-time-to-buy-and-sell-stock">Exercise 14: Best Time to Buy and Sell Stock</a></li><li class="level-2"><a href="#exercise-15-rotate-array">Exercise 15: Rotate Array</a></li><li class="level-2"><a href="#exercise-16-find-all-numbers-disappeared-in-array">Exercise 16: Find All Numbers Disappeared in Array</a></li><li class="level-2"><a href="#exercise-17-intersection-of-two-arrays">Exercise 17: Intersection of Two Arrays</a></li><li class="level-2"><a href="#exercise-18-single-number">Exercise 18: Single Number</a></li><li class="level-2"><a href="#exercise-19-product-of-array-except-self">Exercise 19: Product of Array Except Self</a></li><li class="level-2"><a href="#exercise-20-valid-anagram">Exercise 20: Valid Anagram</a></li><li class="level-2"><a href="#exercise-21-group-anagrams">Exercise 21: Group Anagrams</a></li><li class="level-2"><a href="#exercise-22-longest-consecutive-sequence">Exercise 22: Longest Consecutive Sequence</a></li><li class="level-2"><a href="#exercise-23-string-compression">Exercise 23: String Compression</a></li><li class="level-2"><a href="#exercise-24-is-subsequence">Exercise 24: Is Subsequence</a></li><li class="level-2"><a href="#exercise-25-majority-element">Exercise 25: Majority Element</a></li><li class="level-2"><a href="#common-interview-questions">Common Interview Questions</a></li><li class="level-3"><a href="#q1-can-we-do-better-than-on-for-finding-minmax">Q1: "Can we do better than O(n) for finding min/max?"</a></li><li class="level-3"><a href="#q2-is-two-nested-loops-always-on">Q2: "Is two nested loops always O(n²)?"</a></li><li class="level-3"><a href="#q3-how-can-sorting-strings-be-on-k-when-sort-is-on-log-n">Q3: "How can sorting strings be O(n * k) when sort is O(n log n)?"</a></li><li class="level-3"><a href="#q4-is-o2n-different-from-on">Q4: "Is O(2n) different from O(n)?"</a></li><li class="level-3"><a href="#q5-when-should-i-use-on-space-to-improve-time-complexity">Q5: "When should I use O(n) space to improve time complexity?"</a></li><li class="level-2"><a href="#summary">Summary</a></li></ul></div>
        <h1 id="on---linear-time-complexity-exercises">O(n) - Linear Time Complexity Exercises</h1>
<h2 id="overview">Overview</h2>
<p>O(n) means the algorithm's runtime grows linearly with input size. If input doubles, runtime roughly doubles. This is very common and often the best we can do for problems requiring examining all elements.</p>
<p><strong>Key Characteristics:</strong></p>
<ul><li>Must look at each element at least once</li><li>Single loop through data</li><li>Often optimal for many problems</li><li>Very acceptable complexity</li></ul>
<p><strong>Growth Comparison:</strong></p>
<pre class="language-csharp"><code class="language-csharp">n = 100       → 100 operations
n = 1,000     → 1,000 operations
n = 1,000,000 → 1,000,000 operations</code></pre>
<p><strong>Common Patterns:</strong></p>
<ul><li>Single pass through array/list</li><li>Linear search</li><li>Building hash maps</li><li>String processing</li></ul>
<h2 id="exercise-1-linear-search">Exercise 1: Linear Search</h2>
<p><strong>Problem</strong>: Find if target exists in unsorted array.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - May need to check all elements
// Space: O(1) - Only uses a few variables
public int LinearSearch(int[] arr, int target)
{
    for (int i = 0; i &lt; arr.Length; i++)
    {
        if (arr[i] == target)
            return i;
    }
    return -1;
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li><strong>Best Case</strong>: O(1) - target is first element</li><li><strong>Average Case</strong>: O(n/2) → O(n) - target in middle</li><li><strong>Worst Case</strong>: O(n) - target at end or not present</li><li><strong>When to use</strong>: Unsorted data or very small arrays</li></ul>
<p><strong>Comparison:</strong></p>
<ul><li>Unsorted: Linear search O(n)</li><li>Sorted: Binary search O(log n)</li></ul>
<p>---</p>
<h2 id="exercise-2-find-minimummaximum">Exercise 2: Find Minimum/Maximum</h2>
<p><strong>Problem</strong>: Find the smallest or largest element in an array.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Must check every element
// Space: O(1) - Only stores min value
public int FindMin(int[] arr)
{
    if (arr.Length == 0)
        throw new ArgumentException(&quot;Array is empty&quot;);

    int min = arr[0];
    for (int i = 1; i &lt; arr.Length; i++)
    {
        if (arr[i] &lt; min)
            min = arr[i];
    }
    return min;
}

// Find both min and max: Still O(n)
public (int min, int max) FindMinMax(int[] arr)
{
    if (arr.Length == 0)
        throw new ArgumentException(&quot;Array is empty&quot;);

    int min = arr[0];
    int max = arr[0];

    for (int i = 1; i &lt; arr.Length; i++)
    {
        if (arr[i] &lt; min)
            min = arr[i];
        if (arr[i] &gt; max)
            max = arr[i];
    }

    return (min, max);
}

// Using LINQ (also O(n))
public int FindMinLinq(int[] arr)
{
    return arr.Min();  // O(n)
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Must examine every element (can't skip any)</li><li>No way to do better than O(n) without additional info</li><li><strong>Optimization</strong>: Find both min and max in one pass</li></ul>
<p>---</p>
<h2 id="exercise-3-sum-of-array-elements">Exercise 3: Sum of Array Elements</h2>
<p><strong>Problem</strong>: Calculate sum of all elements.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Visit each element once
// Space: O(1) - Only stores sum
public long SumArray(int[] arr)
{
    long sum = 0;
    for (int i = 0; i &lt; arr.Length; i++)
    {
        sum += arr[i];
    }
    return sum;
}

// Using LINQ (also O(n))
public long SumArrayLinq(int[] arr)
{
    return arr.Sum();  // O(n)
}

// Average: O(n)
public double Average(int[] arr)
{
    if (arr.Length == 0)
        throw new ArgumentException(&quot;Array is empty&quot;);

    return (double)arr.Sum() / arr.Length;  // O(n) + O(1)
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Single pass through array</li><li>Can't compute sum without seeing all elements</li><li>O(n) is optimal for this problem</li></ul>
<p>---</p>
<h2 id="exercise-4-reverse-an-array-in-place">Exercise 4: Reverse an Array In-Place</h2>
<p><strong>Problem</strong>: Reverse array elements without extra space.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Visit n/2 elements, swap each
// Space: O(1) - Only uses temp variable
public void ReverseArray(int[] arr)
{
    int left = 0;
    int right = arr.Length - 1;

    while (left &lt; right)
    {
        // Swap
        int temp = arr[left];
        arr[left] = arr[right];
        arr[right] = temp;

        left++;
        right--;
    }
}

// Using Array.Reverse (also O(n))
public void ReverseArrayBuiltIn(int[] arr)
{
    Array.Reverse(arr);  // O(n)
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Swaps n/2 pairs</li><li>O(n/2) → O(n) after dropping constants</li><li>In-place: O(1) space</li></ul>
<p>---</p>
<h2 id="exercise-5-remove-duplicates-from-sorted-array">Exercise 5: Remove Duplicates from Sorted Array</h2>
<p><strong>Problem</strong>: Remove duplicates in-place from sorted array.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass through array
// Space: O(1) - Only uses index pointer
public int RemoveDuplicates(int[] nums)
{
    if (nums.Length == 0)
        return 0;

    int writeIndex = 1;

    for (int i = 1; i &lt; nums.Length; i++)
    {
        if (nums[i] != nums[i - 1])
        {
            nums[writeIndex] = nums[i];
            writeIndex++;
        }
    }

    return writeIndex;  // New length
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">Input:  [1, 1, 2, 2, 3, 4, 4, 5]
Output: [1, 2, 3, 4, 5, _, _, _]
Length: 5

Process:
i=1: 1==1, skip
i=2: 2!=1, write at 1
i=3: 2==2, skip
i=4: 3!=2, write at 2
i=5: 4!=3, write at 3
i=6: 4==4, skip
i=7: 5!=4, write at 4</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Single pass: O(n)</li><li>Two-pointer technique</li><li>Only works because array is sorted!</li></ul>
<p>---</p>
<h2 id="exercise-6-count-occurrences">Exercise 6: Count Occurrences</h2>
<p><strong>Problem</strong>: Count how many times each element appears.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass to build dictionary
// Space: O(n) - Dictionary stores unique elements
public Dictionary&lt;int, int&gt; CountOccurrences(int[] arr)
{
    var counts = new Dictionary&lt;int, int&gt;();

    foreach (int num in arr)
    {
        if (counts.ContainsKey(num))
            counts[num]++;
        else
            counts[num] = 1;
    }

    return counts;
}

// Using LINQ GroupBy (also O(n))
public Dictionary&lt;int, int&gt; CountOccurrencesLinq(int[] arr)
{
    return arr.GroupBy(x =&gt; x)
              .ToDictionary(g =&gt; g.Key, g =&gt; g.Count());
}

// Count specific value: O(n)
public int CountValue(int[] arr, int target)
{
    int count = 0;
    foreach (int num in arr)
    {
        if (num == target)
            count++;
    }
    return count;
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Each element processed once: O(n)</li><li>Dictionary operations: O(1) average</li><li>Total: O(n)</li></ul>
<p>---</p>
<h2 id="exercise-7-two-sum-hash-map-approach">Exercise 7: Two Sum (Hash Map Approach)</h2>
<p><strong>Problem</strong>: Find two numbers that add up to target.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass with hash map
// Space: O(n) - Store up to n elements in dictionary
public int[] TwoSum(int[] nums, int target)
{
    var map = new Dictionary&lt;int, int&gt;();  // value -&gt; index

    for (int i = 0; i &lt; nums.Length; i++)
    {
        int complement = target - nums[i];

        if (map.ContainsKey(complement))
        {
            return new int[] { map[complement], i };
        }

        map[nums[i]] = i;
    }

    return null;  // No solution
}

// Brute force approach: O(n²)
public int[] TwoSumBruteForce(int[] nums, int target)
{
    for (int i = 0; i &lt; nums.Length; i++)
    {
        for (int j = i + 1; j &lt; nums.Length; j++)
        {
            if (nums[i] + nums[j] == target)
                return new int[] { i, j };
        }
    }
    return null;
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Hash map approach: O(n) time, O(n) space</li><li>Brute force: O(n²) time, O(1) space</li><li>Classic time-space tradeoff!</li></ul>
<p>---</p>
<h2 id="exercise-8-move-zeros-to-end">Exercise 8: Move Zeros to End</h2>
<p><strong>Problem</strong>: Move all zeros to the end, maintaining order of non-zeros.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass
// Space: O(1) - In-place
public void MoveZeros(int[] nums)
{
    int writeIndex = 0;

    // Move all non-zeros to front
    for (int i = 0; i &lt; nums.Length; i++)
    {
        if (nums[i] != 0)
        {
            nums[writeIndex] = nums[i];
            writeIndex++;
        }
    }

    // Fill remaining with zeros
    for (int i = writeIndex; i &lt; nums.Length; i++)
    {
        nums[i] = 0;
    }
}

// Alternative: swap approach (also O(n))
public void MoveZerosSwap(int[] nums)
{
    int writeIndex = 0;

    for (int i = 0; i &lt; nums.Length; i++)
    {
        if (nums[i] != 0)
        {
            int temp = nums[writeIndex];
            nums[writeIndex] = nums[i];
            nums[i] = temp;
            writeIndex++;
        }
    }
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">Input:  [0, 1, 0, 3, 12]
Output: [1, 3, 12, 0, 0]</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Two passes: O(n) + O(n) = O(2n) → O(n)</li><li>Two-pointer technique</li><li>In-place modification</li></ul>
<p>---</p>
<h2 id="exercise-9-contains-duplicate-hash-set">Exercise 9: Contains Duplicate (Hash Set)</h2>
<p><strong>Problem</strong>: Check if array contains any duplicates.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass with hash set
// Space: O(n) - Store up to n elements
public bool ContainsDuplicate(int[] nums)
{
    var seen = new HashSet&lt;int&gt;();

    foreach (int num in nums)
    {
        if (seen.Contains(num))
            return true;

        seen.Add(num);
    }

    return false;
}

// Using LINQ (also O(n))
public bool ContainsDuplicateLinq(int[] nums)
{
    return nums.Length != nums.Distinct().Count();
}

// Brute force: O(n²)
public bool ContainsDuplicateBruteForce(int[] nums)
{
    for (int i = 0; i &lt; nums.Length; i++)
    {
        for (int j = i + 1; j &lt; nums.Length; j++)
        {
            if (nums[i] == nums[j])
                return true;
        }
    }
    return false;
}

// Sort approach: O(n log n)
public bool ContainsDuplicateSort(int[] nums)
{
    Array.Sort(nums);  // O(n log n)
    for (int i = 1; i &lt; nums.Length; i++)
    {
        if (nums[i] == nums[i - 1])
            return true;
    }
    return false;
}</code></pre>
<p><strong>Comparison:</strong></p>
<ul><li>Hash set: O(n) time, O(n) space ✓ Best</li><li>Sort: O(n log n) time, O(1) space</li><li>Brute force: O(n²) time, O(1) space</li></ul>
<p>---</p>
<h2 id="exercise-10-merge-two-sorted-arrays">Exercise 10: Merge Two Sorted Arrays</h2>
<p><strong>Problem</strong>: Merge two sorted arrays into one sorted array.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n + m) - Linear in total elements
// Space: O(n + m) - New array for result
public int[] MergeSortedArrays(int[] arr1, int[] arr2)
{
    int[] result = new int[arr1.Length + arr2.Length];
    int i = 0, j = 0, k = 0;

    while (i &lt; arr1.Length &amp;&amp; j &lt; arr2.Length)
    {
        if (arr1[i] &lt;= arr2[j])
        {
            result[k] = arr1[i];
            i++;
        }
        else
        {
            result[k] = arr2[j];
            j++;
        }
        k++;
    }

    // Copy remaining elements from arr1
    while (i &lt; arr1.Length)
    {
        result[k] = arr1[i];
        i++;
        k++;
    }

    // Copy remaining elements from arr2
    while (j &lt; arr2.Length)
    {
        result[k] = arr2[j];
        j++;
        k++;
    }

    return result;
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Each element from both arrays visited once</li><li>Total: O(n + m) where n = arr1.Length, m = arr2.Length</li><li>Core operation of merge sort!</li></ul>
<p>---</p>
<h2 id="exercise-11-valid-palindrome">Exercise 11: Valid Palindrome</h2>
<p><strong>Problem</strong>: Check if string is a palindrome (ignoring non-alphanumeric).</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass with two pointers
// Space: O(1) - Only uses pointers
public bool IsPalindrome(string s)
{
    int left = 0;
    int right = s.Length - 1;

    while (left &lt; right)
    {
        // Skip non-alphanumeric from left
        while (left &lt; right &amp;&amp; !char.IsLetterOrDigit(s[left]))
            left++;

        // Skip non-alphanumeric from right
        while (left &lt; right &amp;&amp; !char.IsLetterOrDigit(s[right]))
            right--;

        // Compare characters (case-insensitive)
        if (char.ToLower(s[left]) != char.ToLower(s[right]))
            return false;

        left++;
        right--;
    }

    return true;
}

// Using LINQ: O(n) but creates new string
public bool IsPalindromeLinq(string s)
{
    var cleaned = new string(s.Where(char.IsLetterOrDigit)
                              .Select(char.ToLower)
                              .ToArray());

    return cleaned.SequenceEqual(cleaned.Reverse());
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">&quot;A man, a plan, a canal: Panama&quot; → true
&quot;race a car&quot; → false</code></pre>
<p>---</p>
<h2 id="exercise-12-longest-substring-without-repeating-characters">Exercise 12: Longest Substring Without Repeating Characters</h2>
<p><strong>Problem</strong>: Find length of longest substring without duplicates.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Sliding window, each char visited at most twice
// Space: O(min(n, m)) - m is charset size
public int LengthOfLongestSubstring(string s)
{
    var charSet = new HashSet&lt;char&gt;();
    int left = 0;
    int maxLength = 0;

    for (int right = 0; right &lt; s.Length; right++)
    {
        // Shrink window until no duplicates
        while (charSet.Contains(s[right]))
        {
            charSet.Remove(s[left]);
            left++;
        }

        charSet.Add(s[right]);
        maxLength = Math.Max(maxLength, right - left + 1);
    }

    return maxLength;
}

// Using Dictionary to track last index: O(n)
public int LengthOfLongestSubstringDict(string s)
{
    var lastIndex = new Dictionary&lt;char, int&gt;();
    int left = 0;
    int maxLength = 0;

    for (int right = 0; right &lt; s.Length; right++)
    {
        if (lastIndex.ContainsKey(s[right]))
        {
            left = Math.Max(left, lastIndex[s[right]] + 1);
        }

        lastIndex[s[right]] = right;
        maxLength = Math.Max(maxLength, right - left + 1);
    }

    return maxLength;
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">&quot;abcabcbb&quot; → &quot;abc&quot; (length 3)
&quot;bbbbb&quot; → &quot;b&quot; (length 1)
&quot;pwwkew&quot; → &quot;wke&quot; (length 3)</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Sliding window technique</li><li>Right pointer moves n times: O(n)</li><li>Left pointer moves at most n times total: O(n)</li><li>Total: O(2n) → O(n)</li></ul>
<p>---</p>
<h2 id="exercise-13-maximum-subarray-sum-kadanes-algorithm">Exercise 13: Maximum Subarray Sum (Kadane's Algorithm)</h2>
<p><strong>Problem</strong>: Find contiguous subarray with largest sum.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass
// Space: O(1) - Only uses variables
public int MaxSubArray(int[] nums)
{
    int maxSoFar = nums[0];
    int maxEndingHere = nums[0];

    for (int i = 1; i &lt; nums.Length; i++)
    {
        maxEndingHere = Math.Max(nums[i], maxEndingHere + nums[i]);
        maxSoFar = Math.Max(maxSoFar, maxEndingHere);
    }

    return maxSoFar;
}

// Track indices as well: O(n)
public (int sum, int start, int end) MaxSubArrayWithIndices(int[] nums)
{
    int maxSoFar = nums[0];
    int maxEndingHere = nums[0];
    int start = 0, end = 0, tempStart = 0;

    for (int i = 1; i &lt; nums.Length; i++)
    {
        if (nums[i] &gt; maxEndingHere + nums[i])
        {
            maxEndingHere = nums[i];
            tempStart = i;
        }
        else
        {
            maxEndingHere = maxEndingHere + nums[i];
        }

        if (maxEndingHere &gt; maxSoFar)
        {
            maxSoFar = maxEndingHere;
            start = tempStart;
            end = i;
        }
    }

    return (maxSoFar, start, end);
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">[-2, 1, -3, 4, -1, 2, 1, -5, 4]
Best subarray: [4, -1, 2, 1] = 6</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Brilliant O(n) algorithm for classic problem</li><li>Brute force would be O(n²) or O(n³)</li><li>Named after Uyghur computer scientist Jay Kadane</li></ul>
<p>---</p>
<h2 id="exercise-14-best-time-to-buy-and-sell-stock">Exercise 14: Best Time to Buy and Sell Stock</h2>
<p><strong>Problem</strong>: Find maximum profit from one buy and one sell.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass
// Space: O(1) - Only uses variables
public int MaxProfit(int[] prices)
{
    if (prices.Length == 0)
        return 0;

    int minPrice = prices[0];
    int maxProfit = 0;

    for (int i = 1; i &lt; prices.Length; i++)
    {
        maxProfit = Math.Max(maxProfit, prices[i] - minPrice);
        minPrice = Math.Min(minPrice, prices[i]);
    }

    return maxProfit;
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">Prices: [7, 1, 5, 3, 6, 4]
Buy at 1, sell at 6 → Profit = 5</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Track minimum price seen so far</li><li>Calculate profit if we sell today</li><li>O(n) single pass solution</li></ul>
<p>---</p>
<h2 id="exercise-15-rotate-array">Exercise 15: Rotate Array</h2>
<p><strong>Problem</strong>: Rotate array to the right by k steps.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Three reverses
// Space: O(1) - In-place
public void Rotate(int[] nums, int k)
{
    k = k % nums.Length;  // Handle k &gt; n

    // Reverse entire array
    Reverse(nums, 0, nums.Length - 1);

    // Reverse first k elements
    Reverse(nums, 0, k - 1);

    // Reverse remaining elements
    Reverse(nums, k, nums.Length - 1);
}

private void Reverse(int[] nums, int start, int end)
{
    while (start &lt; end)
    {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;
        end--;
    }
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">[1, 2, 3, 4, 5, 6, 7], k = 3

Step 1: Reverse all
[7, 6, 5, 4, 3, 2, 1]

Step 2: Reverse first 3
[5, 6, 7, 4, 3, 2, 1]

Step 3: Reverse remaining
[5, 6, 7, 1, 2, 3, 4]</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Three O(n) operations: O(3n) → O(n)</li><li>Clever in-place algorithm</li><li>Alternative: extra array (O(n) space)</li></ul>
<p>---</p>
<h2 id="exercise-16-find-all-numbers-disappeared-in-array">Exercise 16: Find All Numbers Disappeared in Array</h2>
<p><strong>Problem</strong>: Find all numbers from 1 to n that are missing.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Two passes
// Space: O(1) - If output doesn&#39;t count
public List&lt;int&gt; FindDisappearedNumbers(int[] nums)
{
    // Mark presence by negating value at index
    for (int i = 0; i &lt; nums.Length; i++)
    {
        int index = Math.Abs(nums[i]) - 1;
        if (nums[index] &gt; 0)
            nums[index] = -nums[index];
    }

    // Find indices with positive values (missing numbers)
    var result = new List&lt;int&gt;();
    for (int i = 0; i &lt; nums.Length; i++)
    {
        if (nums[i] &gt; 0)
            result.Add(i + 1);
    }

    return result;
}

// Using HashSet: O(n) time, O(n) space
public List&lt;int&gt; FindDisappearedNumbersSet(int[] nums)
{
    var present = new HashSet&lt;int&gt;(nums);
    var result = new List&lt;int&gt;();

    for (int i = 1; i &lt;= nums.Length; i++)
    {
        if (!present.Contains(i))
            result.Add(i);
    }

    return result;
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">[4, 3, 2, 7, 8, 2, 3, 1]
Missing: [5, 6]</code></pre>
<p>---</p>
<h2 id="exercise-17-intersection-of-two-arrays">Exercise 17: Intersection of Two Arrays</h2>
<p><strong>Problem</strong>: Find common elements between two arrays.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n + m) - Build set + iterate
// Space: O(min(n, m)) - Store smaller set
public int[] Intersection(int[] nums1, int[] nums2)
{
    var set1 = new HashSet&lt;int&gt;(nums1);
    var result = new HashSet&lt;int&gt;();

    foreach (int num in nums2)
    {
        if (set1.Contains(num))
            result.Add(num);
    }

    return result.ToArray();
}

// With duplicates (intersection II)
public int[] Intersect(int[] nums1, int[] nums2)
{
    var counts = new Dictionary&lt;int, int&gt;();

    // Count occurrences in nums1
    foreach (int num in nums1)
    {
        if (counts.ContainsKey(num))
            counts[num]++;
        else
            counts[num] = 1;
    }

    var result = new List&lt;int&gt;();

    // Check nums2 against counts
    foreach (int num in nums2)
    {
        if (counts.ContainsKey(num) &amp;&amp; counts[num] &gt; 0)
        {
            result.Add(num);
            counts[num]--;
        }
    }

    return result.ToArray();
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Build hash set from first array: O(n)</li><li>Check second array: O(m)</li><li>Total: O(n + m)</li></ul>
<p>---</p>
<h2 id="exercise-18-single-number">Exercise 18: Single Number</h2>
<p><strong>Problem</strong>: Find element that appears once (all others appear twice).</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass
// Space: O(1) - Only uses variable
public int SingleNumber(int[] nums)
{
    int result = 0;

    foreach (int num in nums)
    {
        result ^= num;  // XOR
    }

    return result;
}</code></pre>
<p><strong>Why XOR Works:</strong></p>
<pre class="language-csharp"><code class="language-csharp">a ^ a = 0 (anything XOR itself is 0)
a ^ 0 = a (anything XOR 0 is itself)
XOR is commutative and associative

[2, 2, 1]:
2 ^ 2 ^ 1 = 0 ^ 1 = 1

[4, 1, 2, 1, 2]:
4 ^ 1 ^ 2 ^ 1 ^ 2 = 4 ^ (1^1) ^ (2^2) = 4 ^ 0 ^ 0 = 4</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Brilliant O(n) time, O(1) space solution</li><li>Uses bit manipulation properties</li></ul>
<p>---</p>
<h2 id="exercise-19-product-of-array-except-self">Exercise 19: Product of Array Except Self</h2>
<p><strong>Problem</strong>: Return array where each element is product of all others.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Three passes
// Space: O(1) - Output array doesn&#39;t count
public int[] ProductExceptSelf(int[] nums)
{
    int n = nums.Length;
    int[] result = new int[n];

    // Calculate prefix products
    result[0] = 1;
    for (int i = 1; i &lt; n; i++)
    {
        result[i] = result[i - 1] * nums[i - 1];
    }

    // Calculate suffix products and combine
    int suffix = 1;
    for (int i = n - 1; i &gt;= 0; i--)
    {
        result[i] *= suffix;
        suffix *= nums[i];
    }

    return result;
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">Input: [1, 2, 3, 4]

Prefix products:
[1, 1, 2, 6]

Suffix products:
[24, 12, 4, 1]

Result (prefix * suffix):
[24, 12, 8, 6]</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Can't use division (problem constraint)</li><li>O(n) time with O(1) extra space (clever!)</li><li>Uses prefix and suffix products</li></ul>
<p>---</p>
<h2 id="exercise-20-valid-anagram">Exercise 20: Valid Anagram</h2>
<p><strong>Problem</strong>: Check if two strings are anagrams.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Two passes
// Space: O(1) - Fixed size array (26 letters)
public bool IsAnagram(string s, string t)
{
    if (s.Length != t.Length)
        return false;

    int[] counts = new int[26];

    for (int i = 0; i &lt; s.Length; i++)
    {
        counts[s[i] - &#39;a&#39;]++;
        counts[t[i] - &#39;a&#39;]--;
    }

    foreach (int count in counts)
    {
        if (count != 0)
            return false;
    }

    return true;
}

// Using Dictionary: O(n) time, O(k) space where k = unique chars
public bool IsAnagramDict(string s, string t)
{
    if (s.Length != t.Length)
        return false;

    var counts = new Dictionary&lt;char, int&gt;();

    foreach (char c in s)
    {
        if (counts.ContainsKey(c))
            counts[c]++;
        else
            counts[c] = 1;
    }

    foreach (char c in t)
    {
        if (!counts.ContainsKey(c))
            return false;

        counts[c]--;
        if (counts[c] &lt; 0)
            return false;
    }

    return true;
}

// Sorting approach: O(n log n)
public bool IsAnagramSort(string s, string t)
{
    if (s.Length != t.Length)
        return false;

    char[] sArr = s.ToCharArray();
    char[] tArr = t.ToCharArray();

    Array.Sort(sArr);  // O(n log n)
    Array.Sort(tArr);

    return new string(sArr) == new string(tArr);
}</code></pre>
<p><strong>Comparison:</strong></p>
<ul><li>Array counting: O(n) time, O(1) space ✓ Best for lowercase letters</li><li>Dictionary: O(n) time, O(k) space (works with Unicode)</li><li>Sorting: O(n log n) time, O(1) space</li></ul>
<p>---</p>
<h2 id="exercise-21-group-anagrams">Exercise 21: Group Anagrams</h2>
<p><strong>Problem</strong>: Group strings that are anagrams of each other.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n * k) where n = number of strings, k = max string length
// Space: O(n * k) for storage
public List&lt;List&lt;string&gt;&gt; GroupAnagrams(string[] strs)
{
    var groups = new Dictionary&lt;string, List&lt;string&gt;&gt;();

    foreach (string str in strs)
    {
        // Create character count key
        char[] count = new char[26];
        foreach (char c in str)
        {
            count[c - &#39;a&#39;]++;
        }

        string key = new string(count);

        if (!groups.ContainsKey(key))
            groups[key] = new List&lt;string&gt;();

        groups[key].Add(str);
    }

    return new List&lt;List&lt;string&gt;&gt;(groups.Values);
}

// Alternative: sort strings as key (O(n * k log k))
public List&lt;List&lt;string&gt;&gt; GroupAnagramsSort(string[] strs)
{
    var groups = new Dictionary&lt;string, List&lt;string&gt;&gt;();

    foreach (string str in strs)
    {
        char[] chars = str.ToCharArray();
        Array.Sort(chars);  // O(k log k)
        string key = new string(chars);

        if (!groups.ContainsKey(key))
            groups[key] = new List&lt;string&gt;();

        groups[key].Add(str);
    }

    return new List&lt;List&lt;string&gt;&gt;(groups.Values);
}</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Character counting: O(n * k) where k = average string length</li><li>Sorting approach: O(n * k log k)</li><li>Both use O(n * k) space</li></ul>
<p>---</p>
<h2 id="exercise-22-longest-consecutive-sequence">Exercise 22: Longest Consecutive Sequence</h2>
<p><strong>Problem</strong>: Find length of longest consecutive sequence.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Each number visited at most twice
// Space: O(n) - Hash set
public int LongestConsecutive(int[] nums)
{
    var numSet = new HashSet&lt;int&gt;(nums);
    int maxLength = 0;

    foreach (int num in numSet)
    {
        // Only start counting if it&#39;s the beginning of a sequence
        if (!numSet.Contains(num - 1))
        {
            int currentNum = num;
            int currentLength = 1;

            while (numSet.Contains(currentNum + 1))
            {
                currentNum++;
                currentLength++;
            }

            maxLength = Math.Max(maxLength, currentLength);
        }
    }

    return maxLength;
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">[100, 4, 200, 1, 3, 2]
Longest sequence: [1, 2, 3, 4] (length 4)</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Looks like O(n²) with nested loop, but actually O(n)!</li><li>Each number counted only when it's start of sequence</li><li>Each number in inner while visited only once across all iterations</li></ul>
<p>---</p>
<h2 id="exercise-23-string-compression">Exercise 23: String Compression</h2>
<p><strong>Problem</strong>: Compress string using count of repeated characters.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Single pass through string
// Space: O(n) - StringBuilder for result
public string Compress(string s)
{
    if (string.IsNullOrEmpty(s))
        return s;

    var result = new StringBuilder();
    int count = 1;

    for (int i = 1; i &lt; s.Length; i++)
    {
        if (s[i] == s[i - 1])
        {
            count++;
        }
        else
        {
            result.Append(s[i - 1]);
            if (count &gt; 1)
                result.Append(count);

            count = 1;
        }
    }

    // Add last group
    result.Append(s[s.Length - 1]);
    if (count &gt; 1)
        result.Append(count);

    string compressed = result.ToString();
    return compressed.Length &lt; s.Length ? compressed : s;
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">&quot;aabcccccaaa&quot; → &quot;a2b1c5a3&quot; → &quot;a2bc5a3&quot;
&quot;abcd&quot; → &quot;abcd&quot; (no compression)</code></pre>
<p>---</p>
<h2 id="exercise-24-is-subsequence">Exercise 24: Is Subsequence</h2>
<p><strong>Problem</strong>: Check if s is subsequence of t.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) where n = t.Length
// Space: O(1) - Only uses pointers
public bool IsSubsequence(string s, string t)
{
    int sIndex = 0;

    for (int i = 0; i &lt; t.Length &amp;&amp; sIndex &lt; s.Length; i++)
    {
        if (t[i] == s[sIndex])
            sIndex++;
    }

    return sIndex == s.Length;
}</code></pre>
<p><strong>Example:</strong></p>
<pre class="language-csharp"><code class="language-csharp">s = &quot;abc&quot;, t = &quot;ahbgdc&quot; → true
s = &quot;axc&quot;, t = &quot;ahbgdc&quot; → false</code></pre>
<p><strong>Analysis:</strong></p>
<ul><li>Two-pointer technique</li><li>Single pass through t</li><li>O(n) time, O(1) space</li></ul>
<p>---</p>
<h2 id="exercise-25-majority-element">Exercise 25: Majority Element</h2>
<p><strong>Problem</strong>: Find element appearing more than n/2 times.</p>
<pre class="language-csharp"><code class="language-csharp">// Time: O(n) - Boyer-Moore Voting Algorithm
// Space: O(1) - Only uses variables
public int MajorityElement(int[] nums)
{
    int candidate = nums[0];
    int count = 1;

    for (int i = 1; i &lt; nums.Length; i++)
    {
        if (count == 0)
        {
            candidate = nums[i];
            count = 1;
        }
        else if (nums[i] == candidate)
        {
            count++;
        }
        else
        {
            count--;
        }
    }

    return candidate;
}

// Hash map approach: O(n) time, O(n) space
public int MajorityElementMap(int[] nums)
{
    var counts = new Dictionary&lt;int, int&gt;();
    int threshold = nums.Length / 2;

    foreach (int num in nums)
    {
        if (counts.ContainsKey(num))
            counts[num]++;
        else
            counts[num] = 1;

        if (counts[num] &gt; threshold)
            return num;
    }

    return -1;  // No majority
}</code></pre>
<p><strong>Boyer-Moore Analysis:</strong></p>
<ul><li>Brilliant O(n) time, O(1) space algorithm</li><li>Works because majority element appears > n/2 times</li><li>Pairs of different elements cancel out</li></ul>
<p>---</p>
<h2 id="common-interview-questions">Common Interview Questions</h2>
<h3 id="q1-can-we-do-better-than-on-for-finding-minmax">Q1: "Can we do better than O(n) for finding min/max?"</h3>
<p><strong>Answer</strong>: No, we must look at every element at least once. Any element could be the min/max. O(n) is optimal for this problem.</p>
<h3 id="q2-is-two-nested-loops-always-on">Q2: "Is two nested loops always O(n²)?"</h3>
<p><strong>Answer</strong>: Usually yes, but not always! The longest consecutive sequence problem has a nested loop but is O(n) because each element is visited at most twice total, not once per outer iteration.</p>
<h3 id="q3-how-can-sorting-strings-be-on-k-when-sort-is-on-log-n">Q3: "How can sorting strings be O(n * k) when sort is O(n log n)?"</h3>
<p><strong>Answer</strong>: It depends on what n and k represent. If n = number of strings and k = average string length, sorting each string is O(k log k), done n times = O(n * k log k).</p>
<h3 id="q4-is-o2n-different-from-on">Q4: "Is O(2n) different from O(n)?"</h3>
<p><strong>Answer</strong>: No! We drop constants in Big-O. O(2n) = O(3n) = O(100n) = O(n). They all grow linearly.</p>
<h3 id="q5-when-should-i-use-on-space-to-improve-time-complexity">Q5: "When should I use O(n) space to improve time complexity?"</h3>
<p><strong>Answer</strong>: When:</p>
<ul><li>Time complexity improvement is significant (O(n²) → O(n))</li><li>Space is available</li><li>Trading O(n) space for O(n) time is often worth it</li><li>Hash maps are common for this trade-off</li></ul>
<p>---</p>
<h2 id="summary">Summary</h2>
<p>O(n) is very common and often optimal. Key points:</p>
<ul><li><strong>Main Pattern</strong>: Single pass through data</li><li><strong>Common Techniques</strong>: Two pointers, sliding window, hash maps</li><li><strong>Often Optimal</strong>: Problems requiring examining all elements</li><li><strong>Space Trade-offs</strong>: O(n) space can reduce time complexity</li></ul>
<p><strong>Next</strong>: Move on to <a href="./ONLogN-Linearithmic-Time-Exercises.md">ONLogN-Linearithmic-Time-Exercises.md</a> to learn about O(n log n) complexity!</p>
      </article>
    </main>
  </div>
  <footer class="footer">Built for disciplined study & interview drills.</footer>
  <script>
    (() => {
      const select = document.getElementById('theme-select');
      const supported = ['dark2', 'light', 'dark'];
      const saved = sessionStorage.getItem('study-theme');
      const normalized = saved === 'midnight' ? 'dark2' : saved;
      const fallback = 'light';
      const initial = supported.includes(normalized) ? normalized : (window.__studyTheme || fallback);
      document.documentElement.dataset.theme = initial;
      if (select) {
        select.value = initial;
        select.addEventListener('change', (event) => {
          const value = event.target.value;
          const next = supported.includes(value) ? value : fallback;
          document.documentElement.dataset.theme = next;
          sessionStorage.setItem('study-theme', next);
        });
      }
    })();
    (() => {
      const groups = document.querySelectorAll('.sidebar-group');
      if (!groups.length) return;
      const storageKey = 'study-open-groups';
      const saved = sessionStorage.getItem(storageKey);
      const openFromStorage = new Set(saved ? JSON.parse(saved) : []);

      const activeLink = document.querySelector('.nav-link.active');
      const activeGroup = activeLink?.closest('.sidebar-group');
      if (activeGroup?.dataset.group) {
        openFromStorage.add(activeGroup.dataset.group);
      }

      const syncStorage = () => {
        const openIds = Array.from(document.querySelectorAll('.sidebar-group.is-open'))
          .map((group) => group.dataset.group)
          .filter(Boolean);
        sessionStorage.setItem(storageKey, JSON.stringify(openIds));
      };

      const setExpanded = (group, expanded) => {
        const header = group.querySelector('.sidebar-group__header');
        const list = group.querySelector('.sidebar-group__items');
        group.classList.toggle('is-open', expanded);
        header?.setAttribute('aria-expanded', expanded);
        if (list) {
          list.hidden = !expanded;
        }
      };

      groups.forEach((group) => {
        const shouldOpen = openFromStorage.has(group.dataset.group);
        setExpanded(group, shouldOpen);
        const header = group.querySelector('.sidebar-group__header');
        header?.addEventListener('click', () => {
          const next = !group.classList.contains('is-open');
          setExpanded(group, next);
          syncStorage();
        });
      });
    })();
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        const swPath = '..\../service-worker.js';
        navigator.serviceWorker.register(swPath).catch((err) => {
          console.error('Service worker registration failed', err);
        });
      });
    }
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
</body>
</html>