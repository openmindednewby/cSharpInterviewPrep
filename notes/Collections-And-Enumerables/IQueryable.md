## **IQueryable<T> ‚Äî Expression Trees for Remote Queries**

> "Use IQueryable<T> when queries should be translated and executed remotely (databases, APIs), not in memory."

### ‚ùå Bad example:

```csharp
public IEnumerable<Trade> GetTradesForSymbol(string symbol)
{
    return _dbContext.Trades.ToList() // loads ALL trades into memory
                            .Where(t => t.Symbol == symbol); // filters in memory
}

// Caller
var trades = repository.GetTradesForSymbol("AAPL"); // loads millions of rows
```

Using IEnumerable<T> forces full materialization before filtering‚Äîcatastrophic for large datasets.

### ‚úÖ Good example:

```csharp
public IQueryable<Trade> GetTradesForSymbol(string symbol)
{
    return _dbContext.Trades.Where(t => t.Symbol == symbol); // builds expression tree
}

// Caller
var trades = repository.GetTradesForSymbol("AAPL")
                       .OrderByDescending(t => t.Timestamp)
                       .Take(100); // SQL: SELECT TOP 100 ... WHERE Symbol = 'AAPL' ORDER BY ...
```

üëâ IQueryable<T> builds expression trees; EF Core translates to SQL and executes on database.

### üî• Composing queries before execution:

```csharp
public IQueryable<Order> GetOrders()
{
    return _dbContext.Orders;
}

// Caller composes query further
var recentLargeOrders = orderService.GetOrders()
    .Where(o => o.Amount > 10000)
    .Where(o => o.CreatedAt > DateTime.UtcNow.AddDays(-7))
    .OrderByDescending(o => o.Amount); // still no execution

var results = recentLargeOrders.ToList(); // NOW executes as single SQL query
```

üëâ Query composition is deferred until materialization (.ToList(), .First(), foreach).

### üî• Avoiding N+1 queries:

```csharp
// ‚ùå Bad: N+1 problem
public IEnumerable<Order> GetOrdersWithCustomers()
{
    var orders = _dbContext.Orders.ToList(); // 1 query
    foreach (var order in orders)
    {
        var customer = order.Customer; // N queries (lazy loading)
    }
    return orders;
}

// ‚úÖ Good: single query with join
public IQueryable<Order> GetOrdersWithCustomers()
{
    return _dbContext.Orders.Include(o => o.Customer); // SQL JOIN
}
```

üëâ IQueryable<T> enables Include() for eager loading, avoiding N+1 queries.

üí° **In trading systems:**

* Use IQueryable<T> for **database repositories** to push filtering/sorting to SQL.
* Enable **dynamic query composition** for flexible reporting without loading everything.
* Avoid materializing with .ToList() prematurely‚Äîkeep query deferred until final shape is known.

---

## Questions & Answers

**Q: What's the difference between IEnumerable<T> and IQueryable<T>?**

A: IEnumerable<T> executes in-memory (LINQ-to-Objects), IQueryable<T> builds expression trees for remote execution (LINQ-to-SQL, LINQ-to-Entities). Use IQueryable<T> for databases.

**Q: When should I return IQueryable<T> vs IEnumerable<T>?**

A: Return IQueryable<T> from repository methods so callers can compose queries before execution. Return IEnumerable<T> when data is already in memory or query composition isn't needed.

**Q: Can IQueryable<T> be enumerated multiple times?**

A: Yes, but each enumeration re-executes the query against the database. Cache results with .ToList() if multiple enumerations are needed.

**Q: What happens if I use unsupported operations in IQueryable<T>?**

A: Providers throw runtime exceptions if they can't translate operations to SQL (e.g., calling custom C# methods). Use .AsEnumerable() to switch to in-memory for unsupported logic.

**Q: How do I switch from IQueryable<T> to IEnumerable<T>?**

A: Call .AsEnumerable(). This forces remaining operations to execute in-memory via LINQ-to-Objects. Useful for operations EF can't translate.

**Q: What's the performance cost of IQueryable<T>?**

A: Building expression trees has overhead, but it's negligible compared to database I/O. The benefit is pushing work to the database, reducing memory and network costs.

**Q: Can IQueryable<T> be used outside EF Core?**

A: Yes. Any provider implementing IQueryProvider can expose IQueryable<T> (e.g., LINQ-to-MongoDB, OData). Custom providers require implementing expression visitors.

**Q: How does IQueryable<T> relate to SQL injection?**

A: Parameterized queries are generated by providers like EF Core, preventing SQL injection. Never concatenate strings into IQueryable<T> predicates‚Äîuse variables instead.

**Q: Should I expose IQueryable<T> from repositories?**

A: Controversial. Pros: flexible querying. Cons: leaks data access concerns to callers. Consider returning IQueryable<T> for read-only queries, but encapsulate writes.

**Q: What's deferred execution in IQueryable<T>?**

A: Query construction doesn't execute; only enumeration (.ToList(), .First(), foreach) triggers execution. This enables composing filters/projections cheaply before hitting the database.
