<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Senior .NET study guide for Struct Vs Class When To Use Which" />
  <title>Struct Vs Class When To Use Which | C# Interview Prep Cheat Sheet</title>
  <link rel="stylesheet" href="../../assets/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <div>
      <p class="eyebrow">C# Interview Prep</p>
      <h1>Senior .NET Study Portal</h1>
      <p class="subtitle">Ultimate cheat sheets, patterns, and interview-ready scenarios in one place.</p>
    </div>
    <div class="badge">Fast recall</div>
  </header>
  <div class="layout">
    <nav class="sidebar">
      <div class="sidebar-section">
        <h2>Navigation</h2>
        <div class="search-hint">Use Ctrl/Cmd + F for quick lookup</div>
        <div class="nav-groups"><div class="sidebar-group">
      <h3>Notes</h3>
      <ul><li><a href="/notes/sub-notes/Async Await Deep Dive.html">Async Await Deep Dive</a></li><li><a href="/notes/Automapper/AutoMapper.html">AutoMapper</a></li><li><a href="/notes/sub-notes/base-keyword.html">Base Keyword</a></li><li><a href="/notes/sub-notes/CLR & Garbage Collector (GC).html">CLR & Garbage Collector (GC)</a></li><li><a href="/notes/sub-notes/CLR & Garbage Collector (GC) Practical Example.html">CLR & Garbage Collector (GC) Practical Example</a></li><li><a href="/notes/core-concepts.html">Core Concepts</a></li><li><a href="/notes/Design-Patterns/CQRS Pattern.html">CQRS Pattern</a></li><li><a href="/notes/SOLID/D-Dependency-Inversion-Principle-DIP.html">D Dependency Inversion Principle DIP</a></li><li><a href="/notes/Design-Patterns/Decorator Pattern.html">Decorator Pattern</a></li><li><a href="/notes/sub-notes/Dependency Injection Lifetimes.html">Dependency Injection Lifetimes</a></li><li><a href="/notes/error-handling.html">Error Handling</a></li><li><a href="/notes/Design-Patterns/Factory Pattern.html">Factory Pattern</a></li><li><a href="/notes/sub-notes/FIFO Queues in .NET.html">FIFO Queues In .NET</a></li><li><a href="/notes/FluentValidation/FluentValidation.html">FluentValidation</a></li><li><a href="/notes/sub-notes/Forcing Garbage Collection.html">Forcing Garbage Collection</a></li><li><a href="/notes/SOLID/I-Interface-Segregation-Principle-ISP.html">I Interface Segregation Principle ISP</a></li><li><a href="/notes/sub-notes/IDisposable Patterns.html">IDisposable Patterns</a></li><li><a href="/notes/Clean-Architecture/index.html">Index</a></li><li><a href="/notes/DRY/index.html">Index</a></li><li><a href="/notes/Memory-Allocation-Discipline/index.html">Index</a></li><li><a href="/notes/SOLID/index.html">Index</a></li><li><a href="/notes/SOLID/L-Liskov-Substitution-Principle-LSP.html">L Liskov Substitution Principle LSP</a></li><li><a href="/notes/logging.html">Logging</a></li><li><a href="/notes/Design-Patterns/Mediator Pattern.html">Mediator Pattern</a></li><li><a href="/notes/Memory-Allocation-Discipline/Memory Allocation Discipline Example.html">Memory Allocation Discipline Example</a></li><li><a href="/notes/Memory-Allocation-Discipline/Memory Allocation Discipline Example Async.html">Memory Allocation Discipline Example Async</a></li><li><a href="/notes/sub-notes/nameof-keyword.html">Nameof Keyword</a></li><li><a href="/notes/sub-notes/NET Generational Garbage Collection (GC) Deep Dive.html">NET Generational Garbage Collection (GC) Deep Dive</a></li><li><a href="/notes/SOLID/O-Open-Closed-Principle-OCP.html">O Open Closed Principle OCP</a></li><li><a href="/notes/Design-Patterns/Observer Pattern.html">Observer Pattern</a></li><li><a href="/notes/sub-notes/RabbitMQ.html">RabbitMQ</a></li><li><a href="/notes/sub-notes/Reflection Overview.html">Reflection Overview</a></li><li><a href="/notes/SOLID/S-Single-Responsibility-Principle-SRP.html">S Single Responsibility Principle SRP</a></li><li><a href="/notes/sub-notes/Server vs Workstation GC.html">Server Vs Workstation GC</a></li><li><a href="/notes/sub-notes/Sorted Collections Interview Notes.html">Sorted Collections Interview Notes</a></li><li><a href="/notes/sub-notes/Sorting Algorithms.html">Sorting Algorithms</a></li><li><a href="/notes/Design-Patterns/Strategy Pattern.html">Strategy Pattern</a></li><li><a href="/notes/sub-notes/struct vs class when to use which.html">Struct Vs Class When To Use Which</a></li><li><a href="/notes/testing-strategies.html">Testing Strategies</a></li><li><a href="/notes/sub-notes/types.html">Types</a></li></ul>
    </div><div class="sidebar-group">
      <h3>Practice</h3>
      <ul><li><a href="/practice/answers.html">Answers</a></li><li><a href="/practice/csharp-system-design-questions.html">Csharp System Design Questions</a></li><li><a href="/practice/questions.html">Questions</a></li><li><a href="/practice/real exam questions answers/replace int without variable.html">Replace Int Without Variable</a></li><li><a href="/practice/real exam questions answers/struct vs class questions and answers.html">Struct Vs Class Questions And Answers</a></li></ul>
    </div></div>
      </div>
    </nav>
    <main class="content">
      <article class="card">
        <div class="breadcrumbs">notes/sub-notes/struct vs class when to use which.md</div>
        <h2>Struct Vs Class When To Use Which</h2>
        <div class="toc-label">Rapid overview</div>
        <div class="toc"><ul class="toc-list"><li class="level-2"><a href="#conceptual-summary">ğŸ§  Conceptual Summary</a></li><li class="level-2"><a href="#practical-explanation-how-clr-handles-them">âš™ï¸ Practical Explanation (How CLR Handles Them)</a></li><li class="level-3"><a href="#struct">ğŸ§© `struct`</a></li><li class="level-3"><a href="#class">ğŸ§© `class`</a></li><li class="level-2"><a href="#performance-and-design-implications">âš¡ Performance and Design Implications</a></li><li class="level-3"><a href="#when-to-use-struct">âœ… When to use `struct`</a></li><li class="level-3"><a href="#when-not-to-use-struct">ğŸš« When NOT to use `struct`</a></li><li class="level-3"><a href="#boxing-and-hidden-allocations">âš ï¸ Boxing and Hidden Allocations</a></li><li class="level-2"><a href="#real-world-example-hfm-context">ğŸ§© Real-World Example (HFM context)</a></li><li class="level-2"><a href="#memory-visualization">ğŸ§© Memory Visualization</a></li><li class="level-2"><a href="#senior-level-20-second-summary-how-to-answer-in-interview">ğŸ¯ Senior-level 20-second summary (how to answer in interview)</a></li><li class="level-1"><a href="#memory-behavior-struct-vs-class">ğŸ§© Memory Behavior: `struct` vs `class`</a></li><li class="level-2"><a href="#1-basic-memory-layout">1ï¸âƒ£ Basic memory layout</a></li><li class="level-2"><a href="#2-assignment-behavior">2ï¸âƒ£ Assignment behavior</a></li><li class="level-3"><a href="#struct-value-type">âœ… Struct (value type)</a></li><li class="level-3"><a href="#class-reference-type">âœ… Class (reference type)</a></li><li class="level-2"><a href="#3-struct-inside-a-class-inline-layout">3ï¸âƒ£ Struct inside a class (inline layout)</a></li><li class="level-2"><a href="#4-passing-to-methods">4ï¸âƒ£ Passing to methods</a></li><li class="level-2"><a href="#5-heap-fragmentation-and-gc-difference">5ï¸âƒ£ Heap fragmentation and GC difference</a></li><li class="level-2"><a href="#6-summary-diagram">6ï¸âƒ£ âš™ï¸ Summary Diagram</a></li><li class="level-2"><a href="#quick-whiteboard-pitch-for-your-interview">ğŸ§  Quick â€œwhiteboard pitchâ€ for your interview</a></li></ul></div>
        <h2 id="conceptual-summary">ğŸ§  Conceptual Summary</h2>
<p>| Feature                    | <strong><code>struct</code></strong>                                                                  | <strong><code>class</code></strong>                                       | | -------------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------- | | <strong>Type category</strong>          | Value type                                                                    | Reference type                                    | | <strong>Memory allocation</strong>      | Stored <strong>inline</strong> (stack, or inside another object)                           | Stored on <strong>heap</strong>, referenced via pointer        | | <strong>Default behavior</strong>       | Copied by <strong>value</strong> (creates a full copy)                                     | Copied by <strong>reference</strong> (points to same object)   | | <strong>Nullability</strong>            | Cannot be <code>null</code> (unless <code>Nullable&lt;T&gt;</code>)                                       | Can be <code>null</code>                                     | | <strong>Inheritance</strong>            | Cannot inherit from another struct or class; only from <code>ValueType</code>            | Supports inheritance and polymorphism             | | <strong>Interfaces</strong>             | Can implement interfaces                                                      | Can implement interfaces and base classes         | | <strong>Default constructor</strong>    | Cannot define a custom parameterless constructor (C# 10 adds limited support) | Can freely define constructors                    | | <strong>Finalizer / Destructor</strong> | Not supported                                                                 | Supported                                         | | <strong>GC behavior</strong>            | Usually short-lived, reclaimed when out of scope                              | Managed by the <strong>Garbage Collector</strong>              | | <strong>Boxing / Unboxing</strong>      | Converting to/from object/interface causes allocation                         | No boxing/unboxing issues                         | | <strong>Thread safety</strong>          | Safer for small immutable data                                                | Reference types require synchronization if shared |</p>
<p>---</p>
<h2 id="practical-explanation-how-clr-handles-them">âš™ï¸ Practical Explanation (How CLR Handles Them)</h2>
<h3 id="struct">ğŸ§© <code>struct</code></h3>
<ul><li>Lives <strong>inline</strong> â€” if itâ€™s a local variable, itâ€™s on the <strong>stack</strong>; if itâ€™s a field in another object, itâ€™s inside that objectâ€™s memory layout.</li><li>When passed to a method, <strong>a full copy is made</strong> (unless passed by <code>ref</code> or <code>in</code>).</li><li>Ideal for <strong>small, immutable, lightweight data</strong> â€” e.g., coordinates, ticks, prices, GUIDs.</li></ul>
<p><strong>Example:</strong></p>
<pre class="hljs"><code>struct Point
{
    public int X;
    public int Y;
}</code></pre>
<p>Each <code>Point</code> lives inline â€” no GC pressure.</p>
<p>---</p>
<h3 id="class">ğŸ§© <code>class</code></h3>
<ul><li>Lives on the <strong>managed heap</strong>. Variables hold a <strong>reference (pointer)</strong> to the actual object.</li><li>Passed around by reference, so multiple variables can point to the same instance.</li><li>Managed by the <strong>Garbage Collector</strong>.</li></ul>
<p><strong>Example:</strong></p>
<pre class="hljs"><code>class Order
{
    public string Symbol { get; set; }
    public double Price { get; set; }
}</code></pre>
<p>Each <code>Order</code> allocation hits the heap and is tracked by the GC.</p>
<p>---</p>
<h2 id="performance-and-design-implications">âš¡ Performance and Design Implications</h2>
<h3 id="when-to-use-struct">âœ… When to use <code>struct</code></h3>
<p>Use when:</p>
<ul><li>The object is <strong>small (â‰¤ 16 bytes typically)</strong>.</li><li>Itâ€™s <strong>immutable</strong>.</li><li>Youâ€™ll create <strong>many</strong> of them (e.g., millions per second) and want <strong>no GC overhead</strong>.</li><li>Value semantics make sense (copying creates independence).</li></ul>
<p><strong>Example (trading context):</strong></p>
<pre class="hljs"><code>readonly struct Tick
{
    public string Symbol { get; }
    public double Bid { get; }
    public double Ask { get; }
}</code></pre>
<p>Each <code>Tick</code> represents an immutable market data point. Perfect as a <code>struct</code>.</p>
<p>---</p>
<h3 id="when-not-to-use-struct">ğŸš« When NOT to use <code>struct</code></h3>
<p>Avoid when:</p>
<ul><li>Itâ€™s large (lots of fields) â†’ copying becomes expensive.</li><li>You need polymorphism, inheritance, or shared references.</li><li>You mutate the same instance in multiple places.</li></ul>
<p>---</p>
<h3 id="boxing-and-hidden-allocations">âš ï¸ Boxing and Hidden Allocations</h3>
<p>When a struct is treated as an <code>object</code> or cast to an interface, it gets <strong>boxed</strong> â€” copied onto the heap.</p>
<pre class="hljs"><code>struct Point { public int X, Y; }

object obj = new Point(); // BOXED: allocates on heap
Point p = (Point)obj;     // UNBOXED: copy back to stack</code></pre>
<p>So: <strong>value types are not automatically zero-GC</strong> â€” you must use them carefully.</p>
<p>---</p>
<h2 id="real-world-example-hfm-context">ğŸ§© Real-World Example (HFM context)</h2>
<p>If youâ€™re processing <strong>millions of tick messages</strong> per second:</p>
<ul><li>Use a <code>struct</code> (or <code>readonly struct</code>) for individual ticks (lightweight, immutable).</li><li>Use a <code>class</code> for services and entities that manage state, like <code>OrderBook</code>, <code>TradeSession</code>, or <code>CacheManager</code>.</li></ul>
<p><strong>Example:</strong></p>
<pre class="hljs"><code>readonly struct Tick
{
    public string Symbol { get; init; }
    public double Bid { get; init; }
    public double Ask { get; init; }
}

class PriceFeedProcessor
{
    private readonly List&lt;Tick&gt; _ticks = new();

    public void OnTick(Tick tick) =&gt; _ticks.Add(tick);
}</code></pre>
<p>---</p>
<h2 id="memory-visualization">ğŸ§© Memory Visualization</h2>
<pre class="hljs"><code>Stack:
 â”œâ”€ Tick t1 { X=1, Y=2 }   (struct: inline)
 â”œâ”€ Tick t2 = t1 (copied!)
 â””â”€ Order ref â”€â”
               â–¼
Heap:
 â””â”€ { Symbol=&quot;EURUSD&quot;, Price=1.0734 }  (class: heap object)</code></pre>
<p>---</p>
<h2 id="senior-level-20-second-summary-how-to-answer-in-interview">ğŸ¯ Senior-level 20-second summary (how to answer in interview)</h2>
<blockquote><p>â€œA struct is a <strong>value type</strong>, stored inline and copied by value â€” great for <strong>small, immutable data</strong> and <strong>reducing GC pressure</strong>. A class is a <strong>reference type</strong>, stored on the heap, supporting <strong>inheritance and polymorphism</strong>. Structs avoid GC but can cost more to copy if large, and boxing them defeats their advantage. In low-latency systems, we often use small structs like <code>Tick</code> or <code>Point</code> to keep memory tight and predictable.â€</p></blockquote>
<p>---</p>
<p>Would you like me to give you <strong>5 advanced interview questions</strong> around <code>struct</code> vs <code>class</code> (with answers), the kind HFM might use to test your understanding of <strong>memory, GC, and performance</strong>?</p>
<p>Excellent â€” this visual explanation will make your answer <strong>stand out instantly</strong> in a senior-level C# interview (especially at HFM, where they care about performance, GC, and data flow).</p>
<p>Letâ€™s walk through it step by step, from memory layout to how structs and classes behave under assignment and method calls.</p>
<p>---</p>
<h1 id="memory-behavior-struct-vs-class">ğŸ§© Memory Behavior: <code>struct</code> vs <code>class</code></h1>
<h2 id="1-basic-memory-layout">1ï¸âƒ£ Basic memory layout</h2>
<pre class="hljs"><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Stack               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ int x = 10;             â”‚  â”‚
â”‚ â”‚ Point p = {X=1,Y=2};    â”‚  â”‚  â† Struct (value type)
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚   (lives inline here)        â”‚
â”‚                              â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ Order o â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¼â”€â”€â–º Heap
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Heap               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ Order { Id=1, Price=99 }â”‚  â”‚  â† Class (reference type)
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
<p><strong>Explanation:</strong></p>
<ul><li><strong>Struct (<code>Point</code>)</strong> is stored <strong>directly on the stack</strong> or inline within another object.</li><li><strong>Class (<code>Order</code>)</strong> is stored on the <strong>heap</strong>; variables on the stack hold a <em>reference</em> (pointer) to it.</li></ul>
<p>---</p>
<h2 id="2-assignment-behavior">2ï¸âƒ£ Assignment behavior</h2>
<h3 id="struct-value-type">âœ… Struct (value type)</h3>
<pre class="hljs"><code>Point a = new Point { X = 1, Y = 2 };
Point b = a;    // copy!
b.X = 99;
Console.WriteLine(a.X); // 1 (a unaffected)</code></pre>
<p><strong>Memory:</strong></p>
<pre class="hljs"><code>Stack:
 a { X=1, Y=2 }
 b { X=99, Y=2 }   â† completely separate copy</code></pre>
<ul><li>Structs are <strong>copied by value</strong>.</li><li>Each variable has its <strong>own independent copy</strong>.</li><li>No heap allocation â†’ no GC pressure.</li></ul>
<p>---</p>
<h3 id="class-reference-type">âœ… Class (reference type)</h3>
<pre class="hljs"><code>Order o1 = new Order { Id = 1, Price = 99 };
Order o2 = o1;  // copy reference!
o2.Price = 120;
Console.WriteLine(o1.Price); // 120</code></pre>
<p><strong>Memory:</strong></p>
<pre class="hljs"><code>Stack:
 o1 â”€â”
 o2 â”€â”˜â”€â”€â–º Heap: { Id=1, Price=120 }</code></pre>
<ul><li>Classes are <strong>copied by reference</strong> â€” both variables point to the same heap object.</li><li>Modifying one affects the other.</li></ul>
<p>---</p>
<h2 id="3-struct-inside-a-class-inline-layout">3ï¸âƒ£ Struct inside a class (inline layout)</h2>
<pre class="hljs"><code>class Trade
{
    public string Symbol;
    public Point Position;
}</code></pre>
<p><strong>Memory:</strong></p>
<pre class="hljs"><code>Heap: Trade
 â”œâ”€ Symbol â†’ &quot;EURUSD&quot;   (heap reference)
 â””â”€ Position { X=10, Y=20 }  (inline in Trade object)</code></pre>
<p><strong>Insight:</strong> Even though the struct is inside a class (on heap), its <strong>fields are embedded inline</strong> â€” not separate allocations. This reduces pointer indirection and helps cache locality.</p>
<p>---</p>
<h2 id="4-passing-to-methods">4ï¸âƒ£ Passing to methods</h2>
<pre class="hljs"><code>void Move(Point p) { p.X += 10; } // copy!
void MoveRef(ref Point p) { p.X += 10; } // modifies original</code></pre>
<p><strong>Memory visualization:</strong></p>
<pre class="hljs"><code>By value (copy):
 Caller: a { X=1 }
 Method: p { X=1 } â†’ modified to X=11 (copy destroyed)

By ref:
 Caller: a { X=1 }
 Method: p â”€â”
             â””â”€ modifies same memory â†’ X=11 persists</code></pre>
<p>ğŸ’¡ <strong>Interview tip:</strong></p>
<blockquote><p>â€œStructs are copied on method calls unless passed by <code>ref</code> or <code>in</code>. Large structs should be passed by <code>in</code> to avoid copy overhead â€” especially in tight loops or latency-critical code.â€</p></blockquote>
<p>---</p>
<h2 id="5-heap-fragmentation-and-gc-difference">5ï¸âƒ£ Heap fragmentation and GC difference</h2>
<pre class="hljs"><code>Structs:
[Stack]
[Stack frame destroyed â†’ data gone instantly]
â†’ No GC involvement.

Classes:
[Heap]
[Objects live until unreachable]
â†’ GC scans and collects them (Gen0â†’Gen1â†’Gen2)</code></pre>
<p><strong>Key insight:</strong></p>
<ul><li>Structs vanish when they go out of scope â†’ <strong>predictable lifetime</strong>.</li><li>Classes depend on GC cycles â†’ <strong>non-deterministic</strong> reclamation.</li><li>Overusing classes in a high-frequency path (like market ticks) causes <strong>GC churn and pauses</strong>.</li></ul>
<p>---</p>
<h2 id="6-summary-diagram">6ï¸âƒ£ âš™ï¸ Summary Diagram</h2>
<pre class="hljs"><code>STRUCT (Value Type)
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Inline Data  â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ Copied on =  â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ No GC        â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ Pass by ref  â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“
  Great for small immutable data

CLASS (Reference Type)
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Heap Object  â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ Copied ref   â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ Managed by GCâ”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚ Supports OOP â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“
  Great for shared mutable state</code></pre>
<p>---</p>
<h2 id="quick-whiteboard-pitch-for-your-interview">ğŸ§  Quick â€œwhiteboard pitchâ€ for your interview</h2>
<blockquote><p>â€œStructs are value types â€” stored inline, copied by value, no GC involvement, ideal for small immutable data like ticks or coordinates. Classes are reference types â€” heap-allocated, reference-based, and managed by GC. I use structs where I want predictable lifetimes and zero allocations; classes when I need shared, long-lived state or polymorphism.â€</p></blockquote>
<p>---</p>
<p>Would you like me to now create a <strong>visual of memory layout with stack/heap arrows</strong> (an actual diagram you could memorize or even sketch during the interview)? It would show <code>struct</code>, <code>class</code>, and mixed cases (struct-in-class, class-in-struct) clearly.</p>
      </article>
    </main>
  </div>
  <footer class="footer">Built for disciplined study & interview drills.</footer>
</body>
</html>