<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Senior .NET study guide for Error Handling" />
  <title>Error Handling | C# Interview Prep Cheat Sheet</title>
  <link rel="stylesheet" href="../assets/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <header class="site-header">
    <div>
      <p class="eyebrow">C# Interview Prep</p>
      <h1>Senior .NET Study Portal</h1>
      <p class="subtitle">Ultimate cheat sheets, patterns, and interview-ready scenarios in one place.</p>
    </div>
    <div class="badge">Fast recall</div>
  </header>
  <div class="layout">
    <nav class="sidebar">
      <div class="sidebar-section">
        <h2>Navigation</h2>
        <div class="search-hint">Use Ctrl/Cmd + F for quick lookup</div>
        <div class="nav-groups"><div class="sidebar-group">
      <h3>Notes</h3>
      <ul><li><a href="notes/sub-notes/Async Await Deep Dive.html">Async Await Deep Dive</a></li><li><a href="notes/Automapper/AutoMapper.html">AutoMapper</a></li><li><a href="notes/sub-notes/base-keyword.html">Base Keyword</a></li><li><a href="notes/sub-notes/CLR & Garbage Collector (GC).html">CLR & Garbage Collector (GC)</a></li><li><a href="notes/sub-notes/CLR & Garbage Collector (GC) Practical Example.html">CLR & Garbage Collector (GC) Practical Example</a></li><li><a href="notes/core-concepts.html">Core Concepts</a></li><li><a href="notes/Design-Patterns/CQRS Pattern.html">CQRS Pattern</a></li><li><a href="notes/SOLID/D-Dependency-Inversion-Principle-DIP.html">D Dependency Inversion Principle DIP</a></li><li><a href="notes/Design-Patterns/Decorator Pattern.html">Decorator Pattern</a></li><li><a href="notes/sub-notes/Dependency Injection Lifetimes.html">Dependency Injection Lifetimes</a></li><li><a href="notes/error-handling.html">Error Handling</a></li><li><a href="notes/Design-Patterns/Factory Pattern.html">Factory Pattern</a></li><li><a href="notes/sub-notes/FIFO Queues in .NET.html">FIFO Queues In .NET</a></li><li><a href="notes/FluentValidation/FluentValidation.html">FluentValidation</a></li><li><a href="notes/sub-notes/Forcing Garbage Collection.html">Forcing Garbage Collection</a></li><li><a href="notes/SOLID/I-Interface-Segregation-Principle-ISP.html">I Interface Segregation Principle ISP</a></li><li><a href="notes/sub-notes/IDisposable Patterns.html">IDisposable Patterns</a></li><li><a href="notes/Clean-Architecture/index.html">Index</a></li><li><a href="notes/DRY/index.html">Index</a></li><li><a href="notes/Memory-Allocation-Discipline/index.html">Index</a></li><li><a href="notes/SOLID/index.html">Index</a></li><li><a href="notes/SOLID/L-Liskov-Substitution-Principle-LSP.html">L Liskov Substitution Principle LSP</a></li><li><a href="notes/logging.html">Logging</a></li><li><a href="notes/Design-Patterns/Mediator Pattern.html">Mediator Pattern</a></li><li><a href="notes/Memory-Allocation-Discipline/Memory Allocation Discipline Example.html">Memory Allocation Discipline Example</a></li><li><a href="notes/Memory-Allocation-Discipline/Memory Allocation Discipline Example Async.html">Memory Allocation Discipline Example Async</a></li><li><a href="notes/sub-notes/nameof-keyword.html">Nameof Keyword</a></li><li><a href="notes/sub-notes/NET Generational Garbage Collection (GC) Deep Dive.html">NET Generational Garbage Collection (GC) Deep Dive</a></li><li><a href="notes/SOLID/O-Open-Closed-Principle-OCP.html">O Open Closed Principle OCP</a></li><li><a href="notes/Design-Patterns/Observer Pattern.html">Observer Pattern</a></li><li><a href="notes/sub-notes/RabbitMQ.html">RabbitMQ</a></li><li><a href="notes/sub-notes/Reflection Overview.html">Reflection Overview</a></li><li><a href="notes/SOLID/S-Single-Responsibility-Principle-SRP.html">S Single Responsibility Principle SRP</a></li><li><a href="notes/sub-notes/Server vs Workstation GC.html">Server Vs Workstation GC</a></li><li><a href="notes/sub-notes/Sorted Collections Interview Notes.html">Sorted Collections Interview Notes</a></li><li><a href="notes/sub-notes/Sorting Algorithms.html">Sorting Algorithms</a></li><li><a href="notes/Design-Patterns/Strategy Pattern.html">Strategy Pattern</a></li><li><a href="notes/sub-notes/struct vs class when to use which.html">Struct Vs Class When To Use Which</a></li><li><a href="notes/testing-strategies.html">Testing Strategies</a></li><li><a href="notes/sub-notes/types.html">Types</a></li></ul>
    </div><div class="sidebar-group">
      <h3>Practice</h3>
      <ul><li><a href="practice/answers.html">Answers</a></li><li><a href="practice/csharp-system-design-questions.html">Csharp System Design Questions</a></li><li><a href="practice/questions.html">Questions</a></li><li><a href="practice/real exam questions answers/replace int without variable.html">Replace Int Without Variable</a></li><li><a href="practice/real exam questions answers/struct vs class questions and answers.html">Struct Vs Class Questions And Answers</a></li></ul>
    </div></div>
      </div>
    </nav>
    <main class="content">
      <article class="card">
        <div class="breadcrumbs">notes/error-handling.md</div>
        <h2>Error Handling</h2>
        <div class="toc-label">Rapid overview</div>
        <div class="toc"><ul class="toc-list"><li class="level-1"><a href="#error-handling-for-high-performance-highly-available-net-services">Error Handling for High-Performance, Highly Available .NET Services</a></li><li class="level-2"><a href="#principles-and-goals">Principles and Goals</a></li><li class="level-2"><a href="#patterns-to-prefer">Patterns to Prefer</a></li><li class="level-2"><a href="#implementation-guidelines">Implementation Guidelines</a></li><li class="level-2"><a href="#minimal-api-example-problem-details-resilience">Minimal API Example (Problem Details + Resilience)</a></li><li class="level-2"><a href="#sample-resilient-client">Sample Resilient Client</a></li><li class="level-2"><a href="#operational-best-practices">Operational Best Practices</a></li><li class="level-2"><a href="#sample-interview-qa">Sample Interview Q&A</a></li></ul></div>
        <h1 id="error-handling-for-high-performance-highly-available-net-services">Error Handling for High-Performance, Highly Available .NET Services</h1>
<p>Use these notes to articulate how you design resilient error-handling flows that protect throughput, minimize tail latency, and keep services debuggable under load.</p>
<p>---</p>
<h2 id="principles-and-goals">Principles and Goals</h2>
<ul><li><strong>Fail fast, fail safely:</strong> Validate inputs early and return meaningful errors without cascading failures.</li><li><strong>Deterministic paths:</strong> Prefer predictable control flow over broad exception handling; reserve exceptions for truly exceptional conditions.</li><li><strong>Low-overhead:</strong> Avoid unnecessary allocations and reflection in hot paths; keep the happy-path zero-cost when possible.</li><li><strong>Observability built-in:</strong> Emit structured errors with correlation IDs and key context (tenant, region, feature flag) for fast triage.</li><li><strong>Graceful degradation:</strong> Prefer partial availability (cached responses, degraded features) over total failure.</li></ul>
<h2 id="patterns-to-prefer">Patterns to Prefer</h2>
<ul><li><strong>Guard clauses:</strong> Validate arguments and state up front to keep the main logic clear and predictable.</li><li><strong>Typed results:</strong> Use <code>OneOf</code>, <code>ErrorOr</code>, or <code>Result</code>-style return types for expected domain errors; avoid exceptions for flow control.</li><li><strong>Exception filters:</strong> Use <code>catch (Exception ex) when (...)</code> to separate retryable from terminal failures and avoid broad catch blocks.</li><li><strong>Retry with jitter:</strong> Apply exponential backoff plus jitter for transient faults; cap retries to protect latency budgets.</li><li><strong>Circuit breakers and bulkheads:</strong> Short-circuit unhealthy dependencies and isolate pools to prevent resource exhaustion.</li><li><strong>Timeouts and cancellation:</strong> Set timeouts per dependency; honor <code>CancellationToken</code> to shed load quickly.</li><li><strong>Idempotency:</strong> Design operations to be retry-safe (idempotency keys, upserts) so recovery paths don't create duplicates.</li></ul>
<h2 id="implementation-guidelines">Implementation Guidelines</h2>
<ul><li><strong>Boundary enforcement:</strong> Validate DTOs with FluentValidation or <code>IValidatableObject</code>; return <code>400</code>-series responses with actionable messages.</li><li><strong>Centralized exception handling:</strong> Use middleware/filters to translate exceptions into consistent problem-details payloads.</li><li><strong>Structured error contracts:</strong> Standardize fields like <code>errorCode</code>, <code>correlationId</code>, <code>source</code>, and <code>retryable</code> for clients.</li><li><strong>Dependency hygiene:</strong> Wrap external calls (HTTP, DB, queues) with polly policies for retry, circuit-breaker, timeout, and fallback.</li><li><strong>Resource protection:</strong> Use bounded channels/queues; reject requests when buffers are full instead of blocking threads.</li><li><strong>Telemetry alignment:</strong> Log errors with event IDs; emit metrics for error rates, retry counts, circuit state, and fallback usage.</li></ul>
<h2 id="minimal-api-example-problem-details-resilience">Minimal API Example (Problem Details + Resilience)</h2>
<pre class="hljs"><code>var builder = WebApplication.CreateBuilder(args);

builder.Services.AddProblemDetails(options =&gt;
{
    options.CustomizeProblemDetails = context =&gt;
    {
        context.ProblemDetails.Extensions[&quot;correlationId&quot;] = context.HttpContext.TraceIdentifier;
    };
});

builder.Services.AddHttpClient&lt;InventoryClient&gt;(client =&gt;
    client.BaseAddress = new Uri(&quot;https://inventory&quot;))
    .AddTransientHttpErrorPolicy(policy =&gt; policy
        .WaitAndRetryAsync(3, retry =&gt; TimeSpan.FromMilliseconds(50 * Math.Pow(2, retry)))
        .WrapAsync(Policy.TimeoutAsync&lt;HttpResponseMessage&gt;(TimeSpan.FromSeconds(1))));

var app = builder.Build();

app.UseExceptionHandler();
app.UseStatusCodePages();
app.UseMiddleware&lt;RequestCorrelationMiddleware&gt;();
app.UseProblemDetails();

app.MapGet(&quot;/items/{sku}&quot;, async (
    string sku,
    InventoryClient client,
    CancellationToken ct) =&gt;
{
    if (string.IsNullOrWhiteSpace(sku))
    {
        return Results.BadRequest(new ProblemDetails
        {
            Title = &quot;Invalid SKU&quot;,
            Detail = &quot;SKU must be provided&quot;,
            Status = StatusCodes.Status400BadRequest
        });
    }

    var result = await client.FetchAsync(sku, ct);
    return result.Match(
        success =&gt; Results.Ok(success),
        notFound =&gt; Results.NotFound(),
        _ =&gt; Results.StatusCode(StatusCodes.Status503ServiceUnavailable));
});

app.Run();</code></pre>
<h2 id="sample-resilient-client">Sample Resilient Client</h2>
<pre class="hljs"><code>public sealed record InventoryResponse(string Sku, int Quantity);

public class InventoryClient
{
    private static readonly OneOf&lt;InventoryResponse, NotFound&gt; NotFoundResult = new(new NotFound());
    private readonly HttpClient _httpClient;

    public InventoryClient(HttpClient httpClient) =&gt; _httpClient = httpClient;

    public async Task&lt;OneOf&lt;InventoryResponse, NotFound, Error&gt;&gt; FetchAsync(string sku, CancellationToken ct)
    {
        using var request = new HttpRequestMessage(HttpMethod.Get, $&quot;/inventory/{sku}&quot;);
        request.Headers.Add(&quot;X-Correlation-ID&quot;, ct.GetHashCode().ToString());

        try
        {
            using var response = await _httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, ct);

            if (response.StatusCode == HttpStatusCode.NotFound)
            {
                return NotFoundResult;
            }

            response.EnsureSuccessStatusCode();

            await using var stream = await response.Content.ReadAsStreamAsync(ct);
            var payload = await JsonSerializer.DeserializeAsync&lt;InventoryResponse&gt;(stream, cancellationToken: ct);

            return payload ?? new Error(&quot;Empty response&quot;, retryable: false);
        }
        catch (OperationCanceledException) when (ct.IsCancellationRequested)
        {
            return new Error(&quot;Request canceled&quot;, retryable: true);
        }
        catch (HttpRequestException ex) when (ex.StatusCode is null or HttpStatusCode.TooManyRequests)
        {
            return new Error(&quot;Transient HTTP failure&quot;, retryable: true);
        }
        catch (Exception ex)
        {
            return new Error(ex.Message, retryable: false);
        }
    }
}

public sealed record Error(string Message, bool retryable);
public sealed record NotFound;</code></pre>
<h2 id="operational-best-practices">Operational Best Practices</h2>
<ul><li><strong>SLO-aware retries:</strong> Align retry budgets with p99 latency targets; prefer 1â€“3 retries with jitter and a global timeout per request.</li><li><strong>Fast-path success:</strong> Keep happy-path allocations low; cache serializers and validators, pre-size collections, and avoid string formatting unless needed.</li><li><strong>Fallbacks:</strong> Serve from cache, return stale data with warnings, or downgrade features (e.g., no recommendations) when dependencies fail.</li><li><strong>Load shedding:</strong> Use request queues and concurrency limits; return <code>429</code>/<code>503</code> quickly when the system is saturated.</li><li><strong>Chaos-ready:</strong> Continuously inject faults (latency, timeouts, dependency outages) in staging to validate resilience policies.</li><li><strong>Consistent surface area:</strong> Map errors to stable codes and types so clients can automate handling and avoid brittle parsing.</li></ul>
<h2 id="sample-interview-qa">Sample Interview Q&A</h2>
<ul><li><strong>Q:</strong> When do you choose exceptions vs. result types?</li><li><strong>A:</strong> Use exceptions for unexpected, rare failures (null reference, protocol violation). Use <code>Result</code>/<code>OneOf</code> for expected domain outcomes (validation errors, not found) to avoid control-flow via exceptions and keep the hot path allocation-free.</li><li><strong>Q:</strong> How do you keep retries from hurting availability?</li><li><strong>A:</strong> Enforce timeouts, cap retry counts, add jitter to prevent thundering herds, and combine retries with circuit breakers and load shedding.</li><li><strong>Q:</strong> How do you propagate context for debugging?</li><li><strong>A:</strong> Attach correlation IDs and tenant/region info to log scopes and problem-details responses; ensure trace context flows through HTTP/messaging clients.</li><li><strong>Q:</strong> What makes an error contract client-friendly?</li><li><strong>A:</strong> Stable error codes, actionable messages, explicit <code>retryable</code> hints, and sample remediation steps so clients can automate retries or fallbacks.</li><li><strong>Q:</strong> How do you avoid exception cost in hot paths?</li><li><strong>A:</strong> Prefer guard clauses and result types, pre-validate inputs, avoid throwing for predictable states, and use exception filters to keep catch blocks narrow.</li></ul>
      </article>
    </main>
  </div>
  <footer class="footer">Built for disciplined study & interview drills.</footer>
</body>
</html>